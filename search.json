[{"path":[]},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"github-actions","dir":"Articles","previous_headings":"For packages","what":"GitHub Actions","title":"Continuous integration","text":"package GitHub, easiest way GitHub Actions. workflow configuration files use YAML syntax. usethis package great functionality can help workflow files. straightforward way add lintr workflow package use r-lib/actions’s lint example. usethis, need call create workflow file called lint.yaml place correct location, namely .github/workflows directory repository. file configures steps required run lintr::lint_package() package. lintr-bot add comments commit pull request lints found also printed annotations along side status check GitHub. want disable commenting can set environment variable LINTR_COMMENT_BOT=false. project subdirectory like use GitHub Actions annotations, can set options(lintr.github_annotation_project_dir = \"path//project\") make sure annotations point correct paths.","code":"usethis::use_github_action(\"lint\")"},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"travis-ci","dir":"Articles","previous_headings":"For packages","what":"Travis CI","title":"Continuous integration","text":"want run lintr Travis-CI, need Travis install package first. can done adding following line .travis.yml recommend running lintr::lint_package() after_success step build process] Just like GitHub Actions, lintr-bot add comments commit pull request lints found also printed Travis-CI. want disable commenting can set environment variable LINTR_COMMENT_BOT=false.","code":"r_github_packages:   - r-lib/lintr"},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"non-failing-lints","dir":"Articles","previous_headings":"For packages > Travis CI","what":"Non-failing Lints","title":"Continuous integration","text":"Live example package using setup: hibpwned, lintr-bot commenting PR.","code":"after_success:   - R CMD INSTALL $PKG_TARBALL   - Rscript -e 'lintr::lint_package()'"},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"for-projects","dir":"Articles","previous_headings":"","what":"For projects","title":"Continuous integration","text":"limited using lintr packages – can use combination continuous integration project.","code":""},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"github-actions-1","dir":"Articles","previous_headings":"For projects","what":"GitHub Actions","title":"Continuous integration","text":"project GitHub, take advantage GitHub Actions usethis functionality. r-lib/actions includes lint-project example, can use calling:","code":"usethis::use_github_action(\"lint-project\")"},{"path":"https://lintr.r-lib.org/articles/continuous-integration.html","id":"super-linter","dir":"Articles","previous_headings":"For projects","what":"Super-Linter","title":"Continuous integration","text":"lintr powers R lints Super-Linter MegaLinter, provide unified linting experience across many languages. Specifically, execute lintr::lint() R R Markdown files included given project.","code":""},{"path":"https://lintr.r-lib.org/articles/creating_linters.html","id":"writing-the-linter","dir":"Articles","previous_headings":"","what":"Writing the linter","title":"Creating new linters","text":"Describe linter, giving title briefly covering usages discouraged linter active. lines (1) generate Tags section documentation linter1; (2) link full table available linters; (3) mark function export. unfamiliar probably (1), can skipped outside lintr . Next, define name new linter. convention suffix linter names _linter. _linter functions function factories return closure actual linting function. define additional parameters useful linter function declaration (see, e.g. assignment_linter), pipe_call_linter requires additional arguments. closure. called source_expression variable contains top level expressions file linted. call Linter() gives closure class ‘linter’ (also guesses name linter; see ?Linter details). raw text expression available source_file$content. However, generally possible implement linters raw text – consider equals_na_linter. just look == NA text file, ’ll generate many false positives, e.g. comments (# note: .na() proper way check == NA) inside character literals (warning(\"use == NA check missingness\")). ’re also likely generate false negatives, example == NA appear different lines! Working around issues using un-parsed text every situation amounts re-implementing parser. Therefore recommended work tokens source_file$parsed_content source_file$xml_parsed_content, tokenized R parser. tokens obtained parse() utils::getParseData() calls done prior calling new linter. getParseData() returns data.frame information source parse tree file linted. list tokens available r-source/src/main/gram.y. source_file$xml_parsed_content uses xmlparsedata::xml_parse_data() convert getParseData() output XML tree, enables writing linter logic XPath, powerful language expressing paths within nested XML data structure. linters lintr built using XPath powerful language computation abstract syntax tree / parse tree. , return early source_expression expression-level object. get_source_expression() returns object parses input file two ways – done expression--expression, contains expressions file. done facilitate caching. Suppose package long source file (e.g., 100s expressions) – rather run linters every expression every time file updated, caching activated lintr run linter expressions changed. Therefore, preferable write expression-level linters whenever possible. Two types exceptions observed lintr (1) several expressions required ensure linter logic applies (e.g., conjunct_test_linter looks consecutive calls stopifnot(), typically appear consecutive expressions) (2) linter logic simple & fast compute, overhead re-running linter low (e.g., single_quotes_linter). cases, use is_lint_level(source_expression, \"file\"). core linter logic. source_expression$xml_parsed_content copied local variable (strictly necessary facilitates debugging). xpath XPath expression expressions matching discouraged usage. bad_expr result executing logic expression’s XML representation. Let’s examine XPath bit closely: Taken together, means want match expr nodes preceded %>% infix operator whose first child node name. maps pretty closely description pipe_call_linter looking , subtlety mapping R code ’re used show XML representation. expr nodes particular take practice get accustomed – use plentiful XPath-based linters lintr guide get extra practice2. Note: xml2 implements XPath 1.0, lacks helpful features available XPath 2.0. Finally, pass matching XML node(s) xml_nodes_to_lints(), returns Lint objects corresponding “bad” usages found source_expression. See ?Lint ?xml_nodes_to_lints details arguments. Note , message lint always , many linters, message customized closely match observed usage. cases, xml_nodes_to_lint() can conveniently accept function lint_message takes node input converts customized message. See, example, seq_linter.","code":"#' Pipe call linter #' #' Force explicit calls in magrittr pipes, e.g., #' `1:3 %>% sum()` instead of `1:3 %>% sum`. #' @evalRd rd_tags(\"pipe_call_linter\") #' @seealso [linters] for a complete list of linters available in lintr. #' @export pipe_call_linter <- function() { Linter(function(source_expression) { if (!is_lint_level(source_expression, \"expression\")) {   return(list()) } xml <- source_expression$xml_parsed_content  xpath <- \"//expr[preceding-sibling::SPECIAL[text() = '%>%'] and *[1][self::SYMBOL]]\" bad_expr <- xml2::xml_find_all(xml, xpath) //expr                  # global search (//) for 'expr' nodes (R expressions), at any nesting level [                       # node[...] looks for any 'node' satisfying conditions in ...   preceding-sibling::   # \"siblings\" are at the same nesting level in XML     SPECIAL[            # 'SPECIAL' is the parse token for infix operators like %% or %+%       text() = '%>%'    # text() returns the string associated with this node     ]                   #   and                   # combine conditions with 'and'   *                     # match any node   [1]                   # match the first such node   [self::SYMBOL]        # match if the current node is a 'SYMBOL' (i.e., a 'name' in R) ]                       # xml_nodes_to_lints(   bad_expr,   source_expression = source_expression,   lint_message = \"Use explicit calls in magrittr pipes, i.e., `a %>% foo` should be `a %>% foo()`.\",   type = \"warning\" )"},{"path":"https://lintr.r-lib.org/articles/creating_linters.html","id":"writing-linter-tests","dir":"Articles","previous_headings":"","what":"Writing linter tests","title":"Creating new linters","text":"(NB: section uses assignment_linter() simpler examples pipe_continuation_linter().) lintr works best inside testthat unit testing framework, particular, lintr exports lintr::expect_lint() designed companion testthat expectations. can define tests inside separate test_that calls. linters use default form. test series expectations linter using expect_lint. Please see ?expect_lint full description parameters. main three aspects test : Linter returns lints nothing lint, e.g. Linter returns lint something lint, e.g. many edge cases can think might break , e.g. may want test additional lint attributes correct, type, line number, column number, e.g. Finally, good idea test linter reports multiple lints needed, e.g. always better write many tests rather .","code":"test_that(\"returns the correct linting\", { expect_lint(\"blah\", NULL, assignment_linter()) expect_lint(\"blah=1\",   rex(\"Use <-, not =, for assignment.\"),   assignment_linter() ) expect_lint(\"fun((blah = fun(1)))\",   rex(\"Use <-, not =, for assignment.\"),   assignment_linter() ) expect_lint(\"blah=1\",   list(message = \"assignment\", line_number = 1, column_number = 5, type = \"style\"),   assignment_linter() ) expect_lint(\"blah=1; blah=2\",   list(     list(line_number = 1, column_number = 5),     list(line_number = 1, column_number = 13),   )   assignment_linter() )"},{"path":[]},{"path":"https://lintr.r-lib.org/articles/creating_linters.html","id":"more-details-about-writing-tests-for-new-lintr-linters","dir":"Articles","previous_headings":"Contributing to {lintr}","what":"More details about writing tests for new {lintr} linters","title":"Creating new linters","text":"lintr package uses testthat testing. can run currently available tests using devtools::test(). want run tests given file use filter argument devtools::test(). Linter tests put tests/testthat/ folder. test filename linter name prefixed test-, e.g. test-pipe_continuation_linter.R.","code":""},{"path":"https://lintr.r-lib.org/articles/creating_linters.html","id":"adding-your-linter-to-the-default_linters","dir":"Articles","previous_headings":"Contributing to {lintr}","what":"Adding your linter to the default_linters","title":"Creating new linters","text":"linter implements part tidyverse style guide can add default_linters. object created file zzz.R (name ensures always run linters defined). Add linter name default_linters list NULL end, add corresponding test case test script ./tests/testthat/default_linter_testcode.R.","code":""},{"path":"https://lintr.r-lib.org/articles/creating_linters.html","id":"submit-pull-request","dir":"Articles","previous_headings":"Contributing to {lintr}","what":"Submit pull request","title":"Creating new linters","text":"Push changes branch fork lintr repository, submit pull request get linter merged lintr!","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"rstudio","dir":"Articles","previous_headings":"","what":"RStudio","title":"Editor setup","text":"lintr lints automatically displayed RStudio Markers pane (RStudio versions > v0.99.206). RStudio Example order show “Markers” pane RStudio: Menu “Tools” -> “Global Options…”, window title “Options” pop . window: click “Code” left; click “Diagnostics” tab; check “Show diagnostics R”. lint source file test.R type Console lintr::lint(\"test.R\") look result “Markers” pane. package also includes two addins linting current source package. bind addin keyboard shortcut navigate Tools > addins > Browse Addins > Keyboard Shortcuts. ’s recommended use Alt+Shift+L linting current source lint Ctrl+Shift+Alt+L code package. easy remember Alt+Shift+L(int) ;)","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"emacs","dir":"Articles","previous_headings":"","what":"Emacs","title":"Editor setup","text":"lintr built-integration flycheck versions greater 0.23.","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation","dir":"Articles","previous_headings":"Emacs","what":"Installation","title":"Editor setup","text":"lintr fully integrated flycheck using ESS. See installation documentation packages information.","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"configuration","dir":"Articles","previous_headings":"Emacs","what":"Configuration","title":"Editor setup","text":"can also configure linters used. e.g. using different line length cutoff. - M-x customize-option -> flycheck-lintr-linters -> linters_with_defaults(line_length_linter(120))","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"vim---syntastic","dir":"Articles","previous_headings":"","what":"Vim - syntastic","title":"Editor setup","text":"lintr can integrated syntastic --fly linting. Vim Example","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation-1","dir":"Articles","previous_headings":"Vim - syntastic","what":"Installation","title":"Editor setup","text":"Put file syntastic/lintr.vim syntastic/syntax_checkers/r. using pathogen directory ~/.vim/bundles/syntastic/syntax_checkers/r. also need add following lines .vimrc.","code":"let g:syntastic_enable_r_lintr_checker = 1 let g:syntastic_r_checkers = ['lintr']"},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"configuration-1","dir":"Articles","previous_headings":"Vim - syntastic","what":"Configuration","title":"Editor setup","text":"can also configure linters used. e.g. using different line length cutoff.","code":"let g:syntastic_r_lintr_linters = \"linters_with_defaults(line_length_linter(120))\""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"vim---ale","dir":"Articles","previous_headings":"","what":"Vim - ALE","title":"Editor setup","text":"lintr can integrated ALE fly linting.","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation-2","dir":"Articles","previous_headings":"Vim - ALE","what":"Installation","title":"Editor setup","text":"lintr integrated ALE requires additional installation.","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"configuration-2","dir":"Articles","previous_headings":"Vim - ALE","what":"Configuration","title":"Editor setup","text":"can configure linters used, e.g. using different line length cutoff. can also configure whether lint lint_package used. Set 1 lint_package 0 (default) lint. See :h ale_r_lintr information. Note configuration .lintr files supported.","code":"let g:ale_r_lintr_options = \"linters_with_defaults(line_length_linter(120))\" let g:ale_r_lintr_lint_package = 1"},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"sublime-text-3","dir":"Articles","previous_headings":"","what":"Sublime Text 3","title":"Editor setup","text":"lintr can integrated Sublime Linter --fly linting. Sublime Example","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation-3","dir":"Articles","previous_headings":"Sublime Text 3","what":"Installation","title":"Editor setup","text":"Simply install sublimeLinter-contrib-lintr using Package Control. information see Sublime Linter Docs","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"configuration-3","dir":"Articles","previous_headings":"Sublime Text 3","what":"Configuration","title":"Editor setup","text":"can also configure linters used. e.g. disabling assignment linter using different line length cutoff. SublimeLinter User Settings","code":"{       \"linters\": {         \"lintr\": {           \"linters\": \"linters_with_defaults(assignment_linter = NULL, line_length_linter(120))\"         }       }     }"},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"atom","dir":"Articles","previous_headings":"","what":"Atom","title":"Editor setup","text":"lintr can integrated Linter fly linting. Atom Example","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation-4","dir":"Articles","previous_headings":"Atom","what":"Installation","title":"Editor setup","text":"Simply install linter-lintr within Atom command line : information bug reports see Atom linter-lintr.","code":"apm install linter-lintr"},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"visual-studio-code","dir":"Articles","previous_headings":"","what":"Visual Studio Code","title":"Editor setup","text":"Visual Studio Code, vscode-R presents lintr diagnostics languageserver. VS Code Example","code":""},{"path":"https://lintr.r-lib.org/articles/editors.html","id":"installation-5","dir":"Articles","previous_headings":"Visual Studio Code","what":"Installation","title":"Editor setup","text":"Installing languageserver package R vscode-R extension VS Code enable lintr VS Code default run following command lines:","code":"Rscript -e 'install.packages(\"languageserver\")' code --install-extension reditorsupport.r"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"running-lintr-on-a-project","dir":"Articles","previous_headings":"","what":"Running lintr on a project","title":"Using lintr","text":"Checking R project lints can done three different functions: Lint single file using lint(): Lint directory using lint_dir(): apply lint() R source files matching pattern argument. default, means .R files well knitr formats (e.g. .Rmd, .Rnw). lint_dir vectorized path, multiple directories can linted time. Lint relevant directories R package using lint_package(): apply lint_dir() subdirectories usually containing R code packages: R containing package implementation. tests containing test code. inst containing sample code vignettes installed along package. vignettes containing package vignettes. data-raw containing code produce data files. information assumed package structure, see R Packages.","code":"lint(filename = \"R/bad.R\") lint_dir(path = \"R\") lint_package(path = \".\")"},{"path":[]},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"the--lintr-file","dir":"Articles","previous_headings":"Configuring linters","what":"The .lintr file","title":"Using lintr","text":"canonical way configure R projects packages linting create .lintr file project root. file debian control format (?read.dcf), value evaluated R code lintr reading settings. minimal .lintr file can generated running use_lintr() project directory. Lintr supports per-project configuration following fields. linters - see ?linters_with_defaults example specifying non-default linters ?linters_with_tags fine-grained control. exclusions - list filenames exclude linting. can use named item exclude certain lines file. exclude - regex pattern lines exclude linting. Default “# nolint” exclude_start - regex pattern start exclusion range. Default “# nolint start” exclude_end - regex pattern end exclusion range. Default “# nolint end” encoding - encoding used source files. Default inferred .Rproj DESCRIPTION files, fallback UTF-8","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"lintr-file-example","dir":"Articles","previous_headings":"Configuring linters","what":".lintr File Example","title":"Using lintr","text":"example .lintr file uses 120 character line lengths, disables commented_code_linter, excludes couple files.","code":"linters: linters_with_defaults(     line_length_linter(120),      commented_code_linter = NULL   ) exclusions: list(     \"inst/doc/creating_linters.R\" = 1,      \"inst/example/bad.R\",      \"tests/testthat/exclusions-test\"   )"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"other-configuration-options","dir":"Articles","previous_headings":"Configuring linters","what":"Other configuration options","title":"Using lintr","text":"generally, lintr searches settings file according following prioritized list. first one found, , used. options(lintr.linter_file) absolute path, file used. default option \".lintr\". linter file (file named like lintr.linter_file) currently searched directory, .e. directory file passed lint(). run lint_package(), directory can differ linted file. linter file parent directory currently-searched directory, starting deepest path, moving upwards one level time. linter file user’s HOME directory. linter file found, default settings take effect (see defaults).","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"using-options","dir":"Articles","previous_headings":"Configuring linters","what":"Using options()","title":"Using lintr","text":"Values options(), NULL, take precedence linter file (e.g. .lintr). Note key option_name linter file translates R option lintr.option_name. example, options(lintr.exclude = \"# skip lint\") take precedence exclude: # nolint linter file.","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"using-arguments-to-lint","dir":"Articles","previous_headings":"Configuring linters","what":"Using arguments to lint()","title":"Using lintr","text":"settings can also passed arguments linting functions directly. case exclusions, combined globally parsed settings. settings overridden. specified settings changed, remaining settings taken directly defaults, argument parse_settings = FALSE can added function calls. suppress reading .lintr configuration. particularly useful tests exclude example files containing lints package-level .lintr excludes files lints intentional.","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"defaults","dir":"Articles","previous_headings":"Configuring linters","what":"Defaults","title":"Using lintr","text":"default settings lintr intended conform tidyverse style guide. However, behavior can customized using different methods. Apart lintr.linter_file, defaults \".lintr\", following settings: Note default encoding setting depends file linted. Encoding found .Rproj file DESCRIPTION file, encoding overrides default UTF-8.","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"customizing-active-linters","dir":"Articles","previous_headings":"Configuring linters > Defaults","what":"Customizing active linters","title":"Using lintr","text":"want customize linters, can use helper function linters_with_defaults(), keep unnamed linters default settings. Disable linter passing NULL. example, set line length limit 120 characters globally disable no_tab_linter, can put .lintr: default, following linters enabled. applicable, default settings also shown.","code":"linters: linters_with_defaults(     line_length_linter = line_length_linter(120L),     no_tab_linter = NULL   )"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"advanced-programmatic-retrieval-of-linters","dir":"Articles","previous_headings":"Configuring linters > Defaults","what":"Advanced: programmatic retrieval of linters","title":"Using lintr","text":"use cases, may useful specify linters string instead name, .e. \"assignment_linter\" instead writing assignment_linter(). Beware cases, simple get() enough:","code":"library(lintr) #>  #> Attaching package: 'lintr' #> The following object is masked _by_ '.GlobalEnv': #>  #>     default_settings linter_name <- \"assignment_linter\"  withr::with_tempfile(\"tmp\", {   writeLines(\"a = 1\", tmp)    # linter column is just 'get'   print(as.data.frame(lint(tmp, linters = get(linter_name)())))    this_linter <- get(linter_name)()   attr(this_linter, \"name\") <- linter_name   # linter column is 'assignment_linter'   print(as.data.frame(lint(tmp, linters = this_linter)))    # more concise alternative: use eval(call(.))   print(as.data.frame(lint(tmp, linters = eval(call(linter_name))))) }) #>                           filename line_number column_number  type #> 1 /tmp/RtmpJXNmhY/file326844e5f655           1             3 style #>                          message  line linter #> 1 Use <-, not =, for assignment. a = 1    get #>                           filename line_number column_number  type #> 1 /tmp/RtmpJXNmhY/file326844e5f655           1             3 style #>                          message  line            linter #> 1 Use <-, not =, for assignment. a = 1 assignment_linter #>                           filename line_number column_number  type #> 1 /tmp/RtmpJXNmhY/file326844e5f655           1             3 style #>                          message  line            linter #> 1 Use <-, not =, for assignment. a = 1 assignment_linter"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"exclusions","dir":"Articles","previous_headings":"","what":"Exclusions","title":"Using lintr","text":"Sometimes, linters globally disabled. Instead, one might want exclude code linting altogether selectively disable linters part code. Note preferred way excluding lints source code use narrowest possible scope specify exactly linters throw lint marked line. prevents accidental suppression justified lints happen line lint needs suppressed.","code":""},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-lines-of-code","dir":"Articles","previous_headings":"Exclusions","what":"Excluding lines of code","title":"Using lintr","text":"Within source files, special comments can used exclude single lines code linting. lints produced marked line excluded results. default, special comment # nolint: file.R > lint(\"file.R\") file2.R > lint(\"file2.R\") Observe lints suppressed output shown. Sometimes, specific linter needs excluded. case, name linter can appended # nolint comment preceded colon terminated dot.","code":"X = 42L # -------------- this comment overflows the default 80 chars line length. #> ::warning file=<text>,line=1,col=1::file=<text>,line=1,col=1,Variable and function name style should be snake_case or symbols. #> ::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,Use <-, not =, for assignment. #> ::warning file=<text>,line=1,col=81::file=<text>,line=1,col=81,Lines should not be more than 80 characters. X = 42L # nolint ------ this comment overflows the default 80 chars line length."},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-only-some-linters","dir":"Articles","previous_headings":"Exclusions","what":"Excluding only some linters","title":"Using lintr","text":"file3.R > lint(\"file3.R\") Observe object_name_linter suppressed. preferable blanket # nolint statements blanket exclusions may accidentally silence linter intentionally suppressed. Multiple linters can specified listing comma separator: file4.R > lint(\"file4.R\") can also specify linter names unique prefix instead full name: file5.R > lint(\"file5.R\")","code":"X = 42L # nolint: object_name_linter. this comment overflows the default 80 chars line length. #> ::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,Use <-, not =, for assignment. #> ::warning file=<text>,line=1,col=81::file=<text>,line=1,col=81,Lines should not be more than 80 characters. X = 42L # nolint: object_name_linter, line_length_linter. this comment overflows the default 80 chars line length. #> ::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,Use <-, not =, for assignment. X = 42L # nolint: object_name, line_len. this comment still overflows the default 80 chars line length. #> ::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,Use <-, not =, for assignment."},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-multiple-lines-of-codes","dir":"Articles","previous_headings":"Exclusions","what":"Excluding multiple lines of codes","title":"Using lintr","text":"linters disabled contiguous block code, exclude_start exclude_end patterns can used. default # nolint start # nolint end respectively. # nolint start accepts syntax # nolint disable specific linters following lines # nolint end encountered. (lints)","code":"# x <- 42L # print(x) #> ::warning file=<text>,line=1,col=3::file=<text>,line=1,col=3,Commented code should be removed. #> ::warning file=<text>,line=2,col=3::file=<text>,line=2,col=3,Commented code should be removed. # nolint start: commented_code_linter. # x <- 42L # print(x) # nolint end"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-lines-via-the-config-file","dir":"Articles","previous_headings":"Exclusions","what":"Excluding lines via the config file","title":"Using lintr","text":"Individual lines can also excluded via config file setting key exclude list elements corresponding different files. exclude lints line 1 file R/bad.R line_length_linter lines 4 6 file, one can set paths interpreted relative location .lintr file.","code":"exclude: list(     \"R/bad.R\" = list(       1, # global exclusions are unnamed       line_length_linter = 4:6     )   )"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-files-completely","dir":"Articles","previous_headings":"Exclusions","what":"Excluding files completely","title":"Using lintr","text":"linter configuration can also used exclude file entirely, linter file entirely. Use sentinel line number Inf mark lines excluded within file. file given character vector, full exclusion implied.","code":"exclude: list(     # excluded from all lints:     \"R/excluded1.R\",     \"R/excluded2.R\" = Inf,     \"R/excluded3.R\" = list(Inf),     # excluded from line_length_linter:     \"R/no-line-length.R\" = list(       line_length_linter = Inf     )   )"},{"path":"https://lintr.r-lib.org/articles/lintr.html","id":"excluding-directories-completely","dir":"Articles","previous_headings":"Exclusions","what":"Excluding directories completely","title":"Using lintr","text":"Entire directories also recognized supplied strings exclude key. example, exclude renv folder linting R project using renv, set particularly useful projects include external code subdirectories.","code":"exclude: list(     \"renv\"   )"},{"path":"https://lintr.r-lib.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jim Hester. Author, maintainer. Florent Angly. Author. Russ Hyde. Author. Michael Chirico. Author. Kun Ren. Author. Alexander Rosenstock. Author.","code":""},{"path":"https://lintr.r-lib.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hester J, Angly F, Hyde R, Chirico M, Ren K, Rosenstock (2022). lintr: 'Linter' R Code. https://github.com/r-lib/lintr, https://lintr.r-lib.org.","code":"@Manual{,   title = {lintr: A 'Linter' for R Code},   author = {Jim Hester and Florent Angly and Russ Hyde and Michael Chirico and Kun Ren and Alexander Rosenstock},   year = {2022},   note = {https://github.com/r-lib/lintr, https://lintr.r-lib.org}, }"},{"path":"https://lintr.r-lib.org/index.html","id":"lintr","dir":"","previous_headings":"","what":"A Linter for R Code","title":"A Linter for R Code","text":"lintr provides static code analysis R. checks adherence given style, identifying syntax errors possible semantic issues, reports can take action. Watch lintr action following animation:  lintr complementary styler package automatically restyles code, eliminating problems lintr can detect.","code":""},{"path":"https://lintr.r-lib.org/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Linter for R Code","text":"Install stable version CRAN: development version GitHub:","code":"install.packages(\"lintr\") devtools::install_github(\"r-lib/lintr\")"},{"path":"https://lintr.r-lib.org/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"A Linter for R Code","text":"can also run lintr continuous integration within IDE text editor. See vignette(\"continuous-integration\") vignette(\"editors\") details. Without configuration, run default linters. See vignette(\"lintr\") learn modify defaults.","code":"# in a project: lintr::use_lintr(type = \"tidyverse\") usethis::use_github_action(\"lint-project\") lintr::lint_dir()  # in a package: lintr::use_lintr(type = \"tidyverse\") usethis::use_github_action(\"lint\") lintr::lint_package()"},{"path":"https://lintr.r-lib.org/reference/Linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a linter closure — Linter","title":"Create a linter closure — Linter","text":"Create linter closure","code":""},{"path":"https://lintr.r-lib.org/reference/Linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a linter closure — Linter","text":"","code":"Linter(fun, name = linter_auto_name())"},{"path":"https://lintr.r-lib.org/reference/Linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a linter closure — Linter","text":"fun function takes source file returns lint objects. name Default name Linter. Lints produced linter labelled name default.","code":""},{"path":"https://lintr.r-lib.org/reference/Linter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a linter closure — Linter","text":"function class set 'linter'.","code":""},{"path":"https://lintr.r-lib.org/reference/T_and_F_symbol_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"T and F symbol linter — T_and_F_symbol_linter","title":"T and F symbol linter — T_and_F_symbol_linter","text":"Avoid symbols T F (TRUE FALSE).","code":""},{"path":"https://lintr.r-lib.org/reference/T_and_F_symbol_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"T and F symbol linter — T_and_F_symbol_linter","text":"","code":"T_and_F_symbol_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/T_and_F_symbol_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"T and F symbol linter — T_and_F_symbol_linter","text":"best_practices, consistency, default, readability, robustness, style","code":""},{"path":"https://lintr.r-lib.org/reference/absolute_path_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Absolute path linter — absolute_path_linter","title":"Absolute path linter — absolute_path_linter","text":"Check absolute paths used (e.g. \"/var\", \"C:\\System\", \"~/docs\").","code":""},{"path":"https://lintr.r-lib.org/reference/absolute_path_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Absolute path linter — absolute_path_linter","text":"","code":"absolute_path_linter(lax = TRUE)"},{"path":"https://lintr.r-lib.org/reference/absolute_path_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Absolute path linter — absolute_path_linter","text":"lax Less stringent linting, leading fewer false positives. TRUE, lint path strings, contain least two path elements, one least two characters contain alphanumeric chars (including UTF-8), spaces, win32-allowed punctuation","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/absolute_path_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Absolute path linter — absolute_path_linter","text":"best_practices, configurable, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/any_duplicated_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of anyDuplicated() > 0 over any(duplicated(.)) — any_duplicated_linter","title":"Require usage of anyDuplicated() > 0 over any(duplicated(.)) — any_duplicated_linter","text":"anyDuplicated() exists replacement (duplicated(.)) efficient simple objects, worst case efficiency. Therefore used situations instead latter.","code":""},{"path":"https://lintr.r-lib.org/reference/any_duplicated_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of anyDuplicated() > 0 over any(duplicated(.)) — any_duplicated_linter","text":"","code":"any_duplicated_linter()"},{"path":"https://lintr.r-lib.org/reference/any_duplicated_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Require usage of anyDuplicated() > 0 over any(duplicated(.)) — any_duplicated_linter","text":"Also match usage like length(unique(x$col)) == nrow(x), can replaced anyDuplicated(x$col) == 0L.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/any_duplicated_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of anyDuplicated() > 0 over any(duplicated(.)) — any_duplicated_linter","text":"best_practices, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/any_is_na_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of anyNA over any(is.na(.)) — any_is_na_linter","title":"Require usage of anyNA over any(is.na(.)) — any_is_na_linter","text":"anyNA() exists replacement (.na(.)) efficient simple objects, worst case efficiency. Therefore used situations instead latter.","code":""},{"path":"https://lintr.r-lib.org/reference/any_is_na_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of anyNA over any(is.na(.)) — any_is_na_linter","text":"","code":"any_is_na_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/any_is_na_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of anyNA over any(is.na(.)) — any_is_na_linter","text":"best_practices, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/assignment_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Assignment linter — assignment_linter","title":"Assignment linter — assignment_linter","text":"Check <- always used assignment.","code":""},{"path":"https://lintr.r-lib.org/reference/assignment_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assignment linter — assignment_linter","text":"","code":"assignment_linter(allow_cascading_assign = TRUE, allow_right_assign = FALSE)"},{"path":"https://lintr.r-lib.org/reference/assignment_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assignment linter — assignment_linter","text":"allow_cascading_assign Logical, default TRUE. FALSE, <<- ->> allowed. allow_right_assign Logical, default FALSE. TRUE, -> ->> allowed.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/assignment_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Assignment linter — assignment_linter","text":"consistency, default, style","code":""},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Linter metadata from a package — available_linters","title":"Get Linter metadata from a package — available_linters","text":"available_linters() obtains tagged list Linters available package. available_tags() searches available tags.","code":""},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Linter metadata from a package — available_linters","text":"","code":"available_linters(packages = \"lintr\", tags = NULL, exclude_tags = \"deprecated\")  available_tags(packages = \"lintr\")"},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Linter metadata from a package — available_linters","text":"packages character vector packages search linters. tags Optional character vector tags search. linters least one matching tag returned. tags NULL, linters returned. exclude_tags Tags exclude results. Linters least one matching tag returned. except_tags NULL, linters excluded.","code":""},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Linter metadata from a package — available_linters","text":"available_linters returns data frame columns 'linter', 'package' 'tags': linter character column naming function associated linter. package character column containing name package providing linter. tags list column containing tags associated linter. available_tags returns character vector linter tags used packages.","code":""},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":"package-authors","dir":"Reference","previous_headings":"","what":"Package Authors","title":"Get Linter metadata from a package — available_linters","text":"implement available_linters() package, include file inst/lintr/linters.csv package. CSV file must contain columns 'linter' 'tags', UTF-8 encoded. Additional columns silently ignored present columns identified name. row describes linter function name (e.g. \"assignment_linter\") column 'linter'. space-separated tags associated linter (e.g. \"style consistency default\") column 'tags'. Tags snake_case. See available_tags(\"lintr\") find tags already used lintr.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/available_linters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Linter metadata from a package — available_linters","text":"","code":"lintr_linters <- available_linters()  # If the package doesn't exist or isn't installed, an empty data frame will be returned available_linters(\"does-not-exist\") #> [1] linter  package tags    #> <0 rows> (or 0-length row.names)  lintr_linters2 <- available_linters(c(\"lintr\", \"does-not-exist\")) identical(lintr_linters, lintr_linters2) #> [1] TRUE available_tags() #>  [1] \"best_practices\"      \"common_mistakes\"     \"configurable\"        #>  [4] \"consistency\"         \"correctness\"         \"default\"             #>  [7] \"deprecated\"          \"efficiency\"          \"package_development\" #> [10] \"readability\"         \"robustness\"          \"style\""},{"path":"https://lintr.r-lib.org/reference/backport_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Backport linter — backport_linter","title":"Backport linter — backport_linter","text":"Check usage unavailable functions. reliable testing r-devel dependencies.","code":""},{"path":"https://lintr.r-lib.org/reference/backport_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backport linter — backport_linter","text":"","code":"backport_linter(r_version = getRversion())"},{"path":"https://lintr.r-lib.org/reference/backport_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Backport linter — backport_linter","text":"r_version Minimum R version test compatibility","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/backport_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Backport linter — backport_linter","text":"configurable, package_development, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/best_practices_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Best practices linters — best_practices_linters","title":"Best practices linters — best_practices_linters","text":"Linters checking use coding best practices, explicit typing numeric constants.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/best_practices_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Best practices linters — best_practices_linters","text":"following linters tagged 'best_practices': absolute_path_linter any_duplicated_linter any_is_na_linter class_equals_linter commented_code_linter condition_message_linter conjunct_test_linter cyclocomp_linter expect_comparison_linter expect_length_linter expect_named_linter expect_not_linter expect_null_linter expect_s3_class_linter expect_s4_class_linter expect_true_false_linter expect_type_linter extraction_operator_linter fixed_regex_linter ifelse_censor_linter implicit_integer_linter literal_coercion_linter nonportable_path_linter outer_negation_linter paste_linter redundant_ifelse_linter regex_subset_linter seq_linter system_file_linter T_and_F_symbol_linter undesirable_function_linter undesirable_operator_linter unreachable_code_linter unused_import_linter vector_logic_linter yoda_test_linter","code":""},{"path":"https://lintr.r-lib.org/reference/brace_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Brace linter — brace_linter","title":"Brace linter — brace_linter","text":"Perform various style checks related placement spacing curly braces:","code":""},{"path":"https://lintr.r-lib.org/reference/brace_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Brace linter — brace_linter","text":"","code":"brace_linter(allow_single_line = FALSE)"},{"path":"https://lintr.r-lib.org/reference/brace_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Brace linter — brace_linter","text":"allow_single_line TRUE, allow open closed curly pair line.","code":""},{"path":"https://lintr.r-lib.org/reference/brace_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Brace linter — brace_linter","text":"Opening curly braces never line always followed newline. Opening curly braces space . Closing curly braces line unless followed else. Closing curly braces conditions line corresponding else. Either neither branch /else use curly braces, .e., either branches use {...} neither . Functions spanning multiple lines use curly braces.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/brace_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Brace linter — brace_linter","text":"configurable, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/checkstyle_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Checkstyle Report for lint results — checkstyle_output","title":"Checkstyle Report for lint results — checkstyle_output","text":"Generate report linting results using Checkstyle XML format.","code":""},{"path":"https://lintr.r-lib.org/reference/checkstyle_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checkstyle Report for lint results — checkstyle_output","text":"","code":"checkstyle_output(lints, filename = \"lintr_results.xml\")"},{"path":"https://lintr.r-lib.org/reference/checkstyle_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checkstyle Report for lint results — checkstyle_output","text":"lints linting results. filename name output report","code":""},{"path":"https://lintr.r-lib.org/reference/class_equals_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block comparison of class with == — class_equals_linter","title":"Block comparison of class with == — class_equals_linter","text":"Usage like class(x) == \"character\" prone error since class R general vector. correct version S3 classes inherits(): inherits(x, \"character\"). Often, class k . equivalent, example .character() .data.frame().","code":""},{"path":"https://lintr.r-lib.org/reference/class_equals_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block comparison of class with == — class_equals_linter","text":"","code":"class_equals_linter()"},{"path":"https://lintr.r-lib.org/reference/class_equals_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Block comparison of class with == — class_equals_linter","text":"Similar reasoning applies class(x) %% \"character\"","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/class_equals_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block comparison of class with == — class_equals_linter","text":"best_practices, consistency, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/clear_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear the lintr cache — clear_cache","title":"Clear the lintr cache — clear_cache","text":"Clear lintr cache","code":""},{"path":"https://lintr.r-lib.org/reference/clear_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear the lintr cache — clear_cache","text":"","code":"clear_cache(file = NULL, path = NULL)"},{"path":"https://lintr.r-lib.org/reference/clear_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear the lintr cache — clear_cache","text":"file filename whose cache clear. pass NULL, delete caches. path directory store caches. Reads option 'lintr.cache_directory' default.","code":""},{"path":"https://lintr.r-lib.org/reference/clear_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear the lintr cache — clear_cache","text":"0 success, 1 failure, invisibly.","code":""},{"path":"https://lintr.r-lib.org/reference/closed_curly_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Closed curly linter — closed_curly_linter","title":"Closed curly linter — closed_curly_linter","text":"Check closed curly braces line unless follow else, comma, closing bracket.","code":""},{"path":"https://lintr.r-lib.org/reference/closed_curly_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Closed curly linter — closed_curly_linter","text":"","code":"closed_curly_linter(allow_single_line = FALSE)"},{"path":"https://lintr.r-lib.org/reference/closed_curly_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Closed curly linter — closed_curly_linter","text":"allow_single_line TRUE, allow open closed curly pair line.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/closed_curly_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Closed curly linter — closed_curly_linter","text":"configurable, deprecated, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/commas_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Commas linter — commas_linter","title":"Commas linter — commas_linter","text":"Check commas followed spaces, spaces .","code":""},{"path":"https://lintr.r-lib.org/reference/commas_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commas linter — commas_linter","text":"","code":"commas_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/commas_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Commas linter — commas_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/commented_code_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Commented code linter — commented_code_linter","title":"Commented code linter — commented_code_linter","text":"Check commented code outside roxygen blocks.","code":""},{"path":"https://lintr.r-lib.org/reference/commented_code_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commented code linter — commented_code_linter","text":"","code":"commented_code_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/commented_code_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Commented code linter — commented_code_linter","text":"best_practices, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/common_mistakes_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Common mistake linters — common_mistakes_linters","title":"Common mistake linters — common_mistakes_linters","text":"Linters highlighting common mistakes, duplicate arguments.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/common_mistakes_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Common mistake linters — common_mistakes_linters","text":"following linters tagged 'common_mistakes': duplicate_argument_linter equals_na_linter missing_argument_linter missing_package_linter sprintf_linter unused_import_linter","code":""},{"path":"https://lintr.r-lib.org/reference/condition_message_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block usage of paste() and paste0() with messaging functions using ... — condition_message_linter","title":"Block usage of paste() and paste0() with messaging functions using ... — condition_message_linter","text":"stop(paste0(...)) strictly redundant -- stop(...) equivalent. stop(...) also preferable stop(paste(...)). applies default condition functions, .e., stop(), warning(), message(), packageStartupMessage().","code":""},{"path":"https://lintr.r-lib.org/reference/condition_message_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block usage of paste() and paste0() with messaging functions using ... — condition_message_linter","text":"","code":"condition_message_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/condition_message_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block usage of paste() and paste0() with messaging functions using ... — condition_message_linter","text":"best_practices, consistency","code":""},{"path":"https://lintr.r-lib.org/reference/configurable_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Configurable linters — configurable_linters","title":"Configurable linters — configurable_linters","text":"Generic linters support custom configuration needs.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/configurable_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Configurable linters — configurable_linters","text":"following linters tagged 'configurable': absolute_path_linter backport_linter brace_linter closed_curly_linter cyclocomp_linter duplicate_argument_linter line_length_linter missing_argument_linter namespace_linter nonportable_path_linter object_length_linter object_name_linter open_curly_linter semicolon_linter semicolon_terminator_linter todo_comment_linter undesirable_function_linter undesirable_operator_linter unused_import_linter","code":""},{"path":"https://lintr.r-lib.org/reference/conjunct_test_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","title":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","text":"readability test outputs, testing one thing per call testthat::expect_true() preferable, .e., expect_true(); expect_true(B) better expect_true(&& B), expect_false(); expect_false(B) better expect_false(|| B).","code":""},{"path":"https://lintr.r-lib.org/reference/conjunct_test_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","text":"","code":"conjunct_test_linter(allow_named_stopifnot = TRUE)"},{"path":"https://lintr.r-lib.org/reference/conjunct_test_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","text":"allow_named_stopifnot Logical, TRUE default. FALSE, \"named\" calls stopifnot(), available since R 4.0.0 provide helpful messages test failures, also linted.","code":""},{"path":"https://lintr.r-lib.org/reference/conjunct_test_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","text":"Similar reasoning applies && usage inside stopifnot() assertthat::assert_that() calls.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/conjunct_test_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Force && conditions in expect_true(), expect_false() to be written separately — conjunct_test_linter","text":"best_practices, package_development, readability","code":""},{"path":"https://lintr.r-lib.org/reference/consecutive_stopifnot_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Force consecutive calls to stopifnot into just one when possible — consecutive_stopifnot_linter","title":"Force consecutive calls to stopifnot into just one when possible — consecutive_stopifnot_linter","text":"stopifnot() accepts number tests, sequences like stopifnot(x); stopifnot(y) redundant.","code":""},{"path":"https://lintr.r-lib.org/reference/consecutive_stopifnot_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force consecutive calls to stopifnot into just one when possible — consecutive_stopifnot_linter","text":"","code":"consecutive_stopifnot_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/consecutive_stopifnot_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Force consecutive calls to stopifnot into just one when possible — consecutive_stopifnot_linter","text":"consistency, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/consistency_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Consistency linters — consistency_linters","title":"Consistency linters — consistency_linters","text":"Linters checking enforcing consistent alternative multiple syntactically valid ways write something.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/consistency_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Consistency linters — consistency_linters","text":"following linters tagged 'consistency': assignment_linter class_equals_linter condition_message_linter consecutive_stopifnot_linter implicit_integer_linter inner_combine_linter literal_coercion_linter no_tab_linter numeric_leading_zero_linter object_name_linter paste_linter redundant_ifelse_linter seq_linter single_quotes_linter system_file_linter T_and_F_symbol_linter","code":""},{"path":"https://lintr.r-lib.org/reference/correctness_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Correctness linters — correctness_linters","title":"Correctness linters — correctness_linters","text":"Linters highlighting possible programming mistakes, unused variables.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/correctness_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Correctness linters — correctness_linters","text":"following linters tagged 'correctness': duplicate_argument_linter equals_na_linter missing_argument_linter namespace_linter object_usage_linter package_hooks_linter sprintf_linter","code":""},{"path":"https://lintr.r-lib.org/reference/cyclocomp_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Cyclomatic complexity linter — cyclocomp_linter","title":"Cyclomatic complexity linter — cyclocomp_linter","text":"Check overly complicated expressions. See cyclocomp::cyclocomp().","code":""},{"path":"https://lintr.r-lib.org/reference/cyclocomp_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cyclomatic complexity linter — cyclocomp_linter","text":"","code":"cyclocomp_linter(complexity_limit = 15L)"},{"path":"https://lintr.r-lib.org/reference/cyclocomp_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cyclomatic complexity linter — cyclocomp_linter","text":"complexity_limit expressions cyclomatic complexity higher linted, defaults 15. See cyclocomp::cyclocomp().","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/cyclocomp_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Cyclomatic complexity linter — cyclocomp_linter","text":"best_practices, configurable, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/default_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Default linters — default_linters","title":"Default linters — default_linters","text":"List default linters lint(). Use linters_with_defaults() customize . default linters based tidyverse style guide. set default linters follows (parameterised linters, eg, line_length_linter use default argument(s), see ?<linter_name> details):","code":""},{"path":"https://lintr.r-lib.org/reference/default_linters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default linters — default_linters","text":"","code":"default_linters"},{"path":"https://lintr.r-lib.org/reference/default_linters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Default linters — default_linters","text":"object class list length 24.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/default_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Default linters — default_linters","text":"following linters tagged 'default': assignment_linter brace_linter commas_linter commented_code_linter cyclocomp_linter equals_na_linter function_left_parentheses_linter infix_spaces_linter line_length_linter no_tab_linter object_length_linter object_name_linter object_usage_linter paren_body_linter pipe_continuation_linter semicolon_linter seq_linter single_quotes_linter spaces_inside_linter spaces_left_parentheses_linter T_and_F_symbol_linter trailing_blank_lines_linter trailing_whitespace_linter vector_logic_linter","code":""},{"path":"https://lintr.r-lib.org/reference/default_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Default lintr settings — default_settings","title":"Default lintr settings — default_settings","text":"Default lintr settings","code":""},{"path":"https://lintr.r-lib.org/reference/default_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default lintr settings — default_settings","text":"","code":"default_settings"},{"path":"https://lintr.r-lib.org/reference/default_settings.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Default lintr settings — default_settings","text":"object class list length 12.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/default_undesirable_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Default undesirable functions and operators — all_undesirable_functions","title":"Default undesirable functions and operators — all_undesirable_functions","text":"Lists function names operators undesirable_function_linter() undesirable_operator_linter(). list default elements another contains available elements. Use modify_defaults() produce custom list.","code":""},{"path":"https://lintr.r-lib.org/reference/default_undesirable_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default undesirable functions and operators — all_undesirable_functions","text":"","code":"all_undesirable_functions  default_undesirable_functions  all_undesirable_operators  default_undesirable_operators"},{"path":"https://lintr.r-lib.org/reference/default_undesirable_functions.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Default undesirable functions and operators — all_undesirable_functions","text":"named list character strings.","code":""},{"path":"https://lintr.r-lib.org/reference/default_undesirable_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Default undesirable functions and operators — all_undesirable_functions","text":"following functions sometimes regarded undesirable: attach() modifies global search path. Use roxygen2's @importFrom statement packages, :: scripts. browser() pauses execution run likely leftover debugging. removed. debug() traps function causes execution pause function run. removed. debugcall() works similarly debug(), causing execution pause. removed. debugonce() useful interactive debugging. removed. detach() modifies global search path. Detaching environments search path rarely necessary production code. ifelse() type stable. Use /else block scalar logic, use dplyr::if_else()/data.table::fifelse() type stable vectorized logic. .libPaths() permanently modifies library location. Use withr::with_libpaths() temporary change instead. library() modifies global search path. Use roxygen2's @importFrom statement packages, :: scripts. loadNamespace() provide easy way signal failures. Use return value requireNamespace() instead. mapply() type stable. Use Map() guarantee list returned simplify accordingly. options() permanently modifies session options. Use withr::with_options() temporary change instead. par() permanently modifies graphics device parameters. Use withr::with_par() temporary change instead. require() modifies global search path. Use roxygen2's @importFrom statement packages, library() :: scripts. sapply() type stable. Use vapply() appropriate FUN.VALUE= argument obtain type stable simplification. setwd() modifies global working directory. Use withr::with_dir() temporary change instead. sink() permanently redirects output. Use withr::with_sink() temporary redirection instead. source() loads code global environment unless local = TRUE used, can cause unexpected behaviour. substring() replaced substr() appropriate stop= value. Sys.setenv() permanently modifies global environment variables. Use withr::with_envvar() temporary change instead. Sys.setlocale() permanently modifies session locale. Use withr::with_locale() temporary change instead. trace() traps function causes execution arbitrary code function run. removed. undebug() useful interactive debugging debug(). removed. untrace() useful interactive debugging trace(). removed. following operators sometimes regarded undesirable: ::: accesses non-exported functions inside packages. Code relying likely break future versions package functions part public interface may changed removed maintainers without notice. Use public functions via :: instead. <<- ->> assign outside current environment way can hard reason . Prefer fully-encapsulated functions wherever possible, , necessary, assign specific environment assign(). Recall can create environment desired scope new.env().","code":""},{"path":"https://lintr.r-lib.org/reference/deprecated_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated linters — deprecated_linters","title":"Deprecated linters — deprecated_linters","text":"Linters deprecated provided backwards compatiblility . linters excluded linters_with_tags() default.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/deprecated_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Deprecated linters — deprecated_linters","text":"following linters tagged 'deprecated': closed_curly_linter open_curly_linter paren_brace_linter semicolon_terminator_linter","code":""},{"path":"https://lintr.r-lib.org/reference/duplicate_argument_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Duplicate argument linter — duplicate_argument_linter","title":"Duplicate argument linter — duplicate_argument_linter","text":"Check duplicate arguments function calls.","code":""},{"path":"https://lintr.r-lib.org/reference/duplicate_argument_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Duplicate argument linter — duplicate_argument_linter","text":"","code":"duplicate_argument_linter(except = character())"},{"path":"https://lintr.r-lib.org/reference/duplicate_argument_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Duplicate argument linter — duplicate_argument_linter","text":"except character vector function names exceptions.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/duplicate_argument_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Duplicate argument linter — duplicate_argument_linter","text":"common_mistakes, configurable, correctness","code":""},{"path":"https://lintr.r-lib.org/reference/efficiency_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficiency linters — efficiency_linters","title":"Efficiency linters — efficiency_linters","text":"Linters highlighting code efficiency problems, unneccessary function calls.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/efficiency_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Efficiency linters — efficiency_linters","text":"following linters tagged 'efficiency': any_duplicated_linter any_is_na_linter fixed_regex_linter ifelse_censor_linter inner_combine_linter literal_coercion_linter nested_ifelse_linter outer_negation_linter redundant_ifelse_linter regex_subset_linter seq_linter undesirable_function_linter undesirable_operator_linter unneeded_concatenation_linter vector_logic_linter","code":""},{"path":"https://lintr.r-lib.org/reference/equals_na_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Equality check with NA linter — equals_na_linter","title":"Equality check with NA linter — equals_na_linter","text":"Check x == NA x != NA","code":""},{"path":"https://lintr.r-lib.org/reference/equals_na_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equality check with NA linter — equals_na_linter","text":"","code":"equals_na_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/equals_na_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Equality check with NA linter — equals_na_linter","text":"common_mistakes, correctness, default, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/exclude.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclude lines or files from linting — exclude","title":"Exclude lines or files from linting — exclude","text":"Exclude lines files linting","code":""},{"path":"https://lintr.r-lib.org/reference/exclude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclude lines or files from linting — exclude","text":"","code":"exclude(lints, exclusions = settings$exclusions, linter_names = NULL, ...)"},{"path":"https://lintr.r-lib.org/reference/exclude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclude lines or files from linting — exclude","text":"lints need filtered. exclusions manually specified exclusions linter_names character vector names active linters, used parsing inline exclusions. ... additional arguments passed parse_exclusions()","code":""},{"path":"https://lintr.r-lib.org/reference/exclude.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exclude lines or files from linting — exclude","text":"Exclusions can specified three different ways. single line source file. default: # nolint, possibly followed listing linters exclude. listing missing, linters excluded line. default listing format # nolint: linter_name, linter2_name.. may anything colon line exclusion tag listing must terminated full stop (.) linter list respected. line range source file. default: # nolint start, # nolint end. # nolint start accepts linter lists form # nolint. exclusions parameter, named list files named lists linters lines exclude , named list files lines exclude, just filenames want exclude entire file, directory names want exclude files directory.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_comparison_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_gt(x, y) over expect_true(x > y) (and similar) — expect_comparison_linter","title":"Require usage of expect_gt(x, y) over expect_true(x > y) (and similar) — expect_comparison_linter","text":"testthat::expect_gt(), testthat::expect_gte(), testthat::expect_lt(), testthat::expect_lte(), testthat::expect_equal() exist specifically testing comparisons two objects. testthat::expect_true() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_comparison_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_gt(x, y) over expect_true(x > y) (and similar) — expect_comparison_linter","text":"","code":"expect_comparison_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_comparison_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_gt(x, y) over expect_true(x > y) (and similar) — expect_comparison_linter","text":"best_practices, package_development","code":""},{"path":"https://lintr.r-lib.org/reference/expect_identical_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_identical(x, y) where appropriate — expect_identical_linter","title":"Require usage of expect_identical(x, y) where appropriate — expect_identical_linter","text":"Google, testthat::expect_identical() default/go-function comparing output expected value. expect_true(identical(x, y)) equivalent unadvised method test. , testthat::expect_equal() used expect_identical() inappropriate, .e., x y need numerically equivalent instead fully identical (case, provide tolerance= argument expect_equal() explicitly). also applies inconvenient check full equality (e.g., names can ignored, case ignore_attr = \"names\" supplied expect_equal() (, 2nd edition, check.attributes = FALSE).","code":""},{"path":"https://lintr.r-lib.org/reference/expect_identical_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_identical(x, y) where appropriate — expect_identical_linter","text":"","code":"expect_identical_linter()"},{"path":"https://lintr.r-lib.org/reference/expect_identical_linter.html","id":"exceptions","dir":"Reference","previous_headings":"","what":"Exceptions","title":"Require usage of expect_identical(x, y) where appropriate — expect_identical_linter","text":"linter allows expect_equal() three circumstances: named argument set (e.g. ignore_attr tolerance) Comparison made explicit decimal, e.g. expect_equal(x, 1.0) (implicitly setting tolerance) ... passed (wrapper functions whcih might set arguments ignore_attr tolerance)","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_identical_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_identical(x, y) where appropriate — expect_identical_linter","text":"package_development","code":""},{"path":"https://lintr.r-lib.org/reference/expect_length_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_length(x, n) over expect_equal(length(x), n) — expect_length_linter","title":"Require usage of expect_length(x, n) over expect_equal(length(x), n) — expect_length_linter","text":"testthat::expect_length() exists specifically testing length() object. testthat::expect_equal() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_length_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_length(x, n) over expect_equal(length(x), n) — expect_length_linter","text":"","code":"expect_length_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_length_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_length(x, n) over expect_equal(length(x), n) — expect_length_linter","text":"best_practices, package_development, readability","code":""},{"path":"https://lintr.r-lib.org/reference/expect_lint.html","id":null,"dir":"Reference","previous_headings":"","what":"Lint expectation — expect_lint","title":"Lint expectation — expect_lint","text":"expectation function test lints produced lint satisfy number checks.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_lint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lint expectation — expect_lint","text":"","code":"expect_lint(content, checks, ..., file = NULL, language = \"en\")"},{"path":"https://lintr.r-lib.org/reference/expect_lint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lint expectation — expect_lint","text":"content character vector file content linted, vector element representing line text. checks checks performed: NULL check lints returned. single string regex object check single lint returned matching message. named list check single lint returned fields match. Accepted fields taken Lint(). list named lists multiple lints returned, check matches checks corresponding named list (described point ). Named vectors also accepted instead named lists, compatibility feature recommended new code. ... arguments passed lint(), e.g. linters cache use. file NULL, read content specified file rather content. language temporarily override Rs LANGUAGE envvar, controlling localisation base R error messages. makes testing reproducible systems irrespective native R language setting.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_lint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lint expectation — expect_lint","text":"NULL, invisibly.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_lint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lint expectation — expect_lint","text":"","code":"# no expected lint expect_lint(\"a\", NULL, trailing_blank_lines_linter) #> Warning:  Passing linters as variables was deprecated in lintr version 2.0.1.9001. Use a call to the linters (see ?linters) instead.  # one expected lint expect_lint(\"a\\n\", \"superfluous\", trailing_blank_lines_linter) #> Warning:  Passing linters as variables was deprecated in lintr version 2.0.1.9001. Use a call to the linters (see ?linters) instead. expect_lint(\"a\\n\", list(message=\"superfluous\", line_number=2), trailing_blank_lines_linter) #> Warning:  Passing linters as variables was deprecated in lintr version 2.0.1.9001. Use a call to the linters (see ?linters) instead.  # several expected lints expect_lint(\"a\\n\\n\", list(\"superfluous\", \"superfluous\"), trailing_blank_lines_linter) #> Warning:  Passing linters as variables was deprecated in lintr version 2.0.1.9001. Use a call to the linters (see ?linters) instead. expect_lint(   \"a\\n\\n\",   list(list(message=\"superfluous\", line_number=2), list(message=\"superfluous\", line_number=3)),   trailing_blank_lines_linter() )"},{"path":"https://lintr.r-lib.org/reference/expect_lint_free.html","id":null,"dir":"Reference","previous_headings":"","what":"Test that the package is lint free — expect_lint_free","title":"Test that the package is lint free — expect_lint_free","text":"function thin wrapper around lint_package simply tests lints package.  can used ensure tests fail package contains lints.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_lint_free.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test that the package is lint free — expect_lint_free","text":"","code":"expect_lint_free(...)"},{"path":"https://lintr.r-lib.org/reference/expect_lint_free.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test that the package is lint free — expect_lint_free","text":"... arguments passed lint_package()","code":""},{"path":"https://lintr.r-lib.org/reference/expect_named_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_named(x, n) over expect_equal(names(x), n) — expect_named_linter","title":"Require usage of expect_named(x, n) over expect_equal(names(x), n) — expect_named_linter","text":"testthat::expect_named() exists specifically testing names() object. testthat::expect_equal() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_named_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_named(x, n) over expect_equal(names(x), n) — expect_named_linter","text":"","code":"expect_named_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_named_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_named(x, n) over expect_equal(names(x), n) — expect_named_linter","text":"best_practices, package_development, readability","code":""},{"path":"https://lintr.r-lib.org/reference/expect_not_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_false(.) over expect_true(!.) — expect_not_linter","title":"Require usage of expect_false(.) over expect_true(!.) — expect_not_linter","text":"testthat::expect_false() exists specifically testing output FALSE. testthat::expect_true() can also used tests negating output, better use tailored function instead. reverse also true -- use expect_false() instead expect_true(!).","code":""},{"path":"https://lintr.r-lib.org/reference/expect_not_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_false(.) over expect_true(!.) — expect_not_linter","text":"","code":"expect_not_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_not_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_false(.) over expect_true(!.) — expect_not_linter","text":"best_practices, package_development, readability","code":""},{"path":"https://lintr.r-lib.org/reference/expect_null_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"expect_null Linter — expect_null_linter","title":"expect_null Linter — expect_null_linter","text":"Require usage expect_null(x) expect_equal(x, NULL) similar usages.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_null_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"expect_null Linter — expect_null_linter","text":"","code":"expect_null_linter()"},{"path":"https://lintr.r-lib.org/reference/expect_null_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"expect_null Linter — expect_null_linter","text":"testthat::expect_null() exists specifically testing NULL objects. testthat::expect_equal(), testthat::expect_identical(), testthat::expect_true() can also used tests, better use tailored function instead.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_null_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"expect_null Linter — expect_null_linter","text":"best_practices, package_development","code":""},{"path":"https://lintr.r-lib.org/reference/expect_s3_class_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_s3_class() — expect_s3_class_linter","title":"Require usage of expect_s3_class() — expect_s3_class_linter","text":"testthat::expect_s3_class() exists specifically testing class S3 objects. testthat::expect_equal(), testthat::expect_identical(), testthat::expect_true() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_s3_class_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_s3_class() — expect_s3_class_linter","text":"","code":"expect_s3_class_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_s3_class_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_s3_class() — expect_s3_class_linter","text":"best_practices, package_development","code":""},{"path":"https://lintr.r-lib.org/reference/expect_s4_class_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_s4_class(x, k) over expect_true(is(x, k)) — expect_s4_class_linter","title":"Require usage of expect_s4_class(x, k) over expect_true(is(x, k)) — expect_s4_class_linter","text":"testthat::expect_s4_class() exists specifically testing class S4 objects. testthat::expect_true() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_s4_class_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_s4_class(x, k) over expect_true(is(x, k)) — expect_s4_class_linter","text":"","code":"expect_s4_class_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_s4_class_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_s4_class(x, k) over expect_true(is(x, k)) — expect_s4_class_linter","text":"best_practices, package_development","code":""},{"path":"https://lintr.r-lib.org/reference/expect_true_false_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_true(x) over expect_equal(x, TRUE) — expect_true_false_linter","title":"Require usage of expect_true(x) over expect_equal(x, TRUE) — expect_true_false_linter","text":"testthat::expect_true() testthat::expect_false() exist specifically testing TRUE/FALSE value object. testthat::expect_equal() testthat::expect_identical() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_true_false_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_true(x) over expect_equal(x, TRUE) — expect_true_false_linter","text":"","code":"expect_true_false_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_true_false_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_true(x) over expect_equal(x, TRUE) — expect_true_false_linter","text":"best_practices, package_development, readability","code":""},{"path":"https://lintr.r-lib.org/reference/expect_type_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of expect_type(x, type) over expect_equal(typeof(x), type) — expect_type_linter","title":"Require usage of expect_type(x, type) over expect_equal(typeof(x), type) — expect_type_linter","text":"testthat::expect_type() exists specifically testing storage type objects. testthat::expect_equal(), testthat::expect_identical(), testthat::expect_true() can also used tests, better use tailored function instead.","code":""},{"path":"https://lintr.r-lib.org/reference/expect_type_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of expect_type(x, type) over expect_equal(typeof(x), type) — expect_type_linter","text":"","code":"expect_type_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/expect_type_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of expect_type(x, type) over expect_equal(typeof(x), type) — expect_type_linter","text":"best_practices, package_development","code":""},{"path":"https://lintr.r-lib.org/reference/extraction_operator_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction operator linter — extraction_operator_linter","title":"Extraction operator linter — extraction_operator_linter","text":"Check [[ operator used extracting single element object, [ (subsetting) $ (interactive use).","code":""},{"path":"https://lintr.r-lib.org/reference/extraction_operator_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction operator linter — extraction_operator_linter","text":"","code":"extraction_operator_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/extraction_operator_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Extraction operator linter — extraction_operator_linter","text":"best_practices, style","code":""},{"path":"https://lintr.r-lib.org/reference/fixed_regex_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of fixed=TRUE in regular expressions where appropriate — fixed_regex_linter","title":"Require usage of fixed=TRUE in regular expressions where appropriate — fixed_regex_linter","text":"Invoking regular expression engine overkill cases search pattern involves static patterns.","code":""},{"path":"https://lintr.r-lib.org/reference/fixed_regex_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of fixed=TRUE in regular expressions where appropriate — fixed_regex_linter","text":"","code":"fixed_regex_linter()"},{"path":"https://lintr.r-lib.org/reference/fixed_regex_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Require usage of fixed=TRUE in regular expressions where appropriate — fixed_regex_linter","text":"NB: stringr functions, means wrapping pattern stringr::fixed(). NB: linter likely able distinguish every possible case fixed regular expression preferable, rather seeks identify likely cases. never report false positives, however; please report false positives error.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/fixed_regex_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of fixed=TRUE in regular expressions where appropriate — fixed_regex_linter","text":"best_practices, efficiency, readability","code":""},{"path":"https://lintr.r-lib.org/reference/function_left_parentheses_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Function left parentheses linter — function_left_parentheses_linter","title":"Function left parentheses linter — function_left_parentheses_linter","text":"Check left parentheses function call spaces .","code":""},{"path":"https://lintr.r-lib.org/reference/function_left_parentheses_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function left parentheses linter — function_left_parentheses_linter","text":"","code":"function_left_parentheses_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/function_left_parentheses_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Function left parentheses linter — function_left_parentheses_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/get_source_expressions.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsed sourced file from a filename — get_source_expressions","title":"Parsed sourced file from a filename — get_source_expressions","text":"object given input linter","code":""},{"path":"https://lintr.r-lib.org/reference/get_source_expressions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsed sourced file from a filename — get_source_expressions","text":"","code":"get_source_expressions(filename, lines = NULL)"},{"path":"https://lintr.r-lib.org/reference/get_source_expressions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsed sourced file from a filename — get_source_expressions","text":"filename file parsed. lines character vector lines. NULL, filename read.","code":""},{"path":"https://lintr.r-lib.org/reference/get_source_expressions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsed sourced file from a filename — get_source_expressions","text":"list three components: expressions list n+1 objects. first n elements correspond expression filename, consist list 9 elements: filename (character) line (integer) line filename expression begins column (integer) column filename expression begins lines (named character) vector lines spanned expression, named line number corresponding filename parsed_content (data.frame) given utils::getParseData() expression xml_parsed_content (xml_document) XML parse tree expression given xmlparsedata::xml_parse_data() content (character) lines single string (split across lines) find_line (function) function returning lines expression find_column (function) similar function columns final element expressions list corresponding full file consisting 6 elements: filename (character) file_lines (character) readLines() output file content (character) .R files, file_lines; .Rmd scripts, extracted R source code (text) full_parsed_content (data.frame) given utils::getParseData() full content full_xml_parsed_content (xml_document) XML parse tree expressions given xmlparsedata::xml_parse_data() terminal_newline (logical) records whether filename terminal newline (determined readLines() producing corresponding warning) error Lint object describing parsing error. lines readLines() output file.","code":""},{"path":"https://lintr.r-lib.org/reference/get_source_expressions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsed sourced file from a filename — get_source_expressions","text":"file read using encoding setting. setting found taking first valid result following locations encoding key usual lintr configuration settings. Encoding field Package DESCRIPTION file parent directory. Encoding field R Project .Rproj file parent directory. \"UTF-8\" fallback.","code":""},{"path":"https://lintr.r-lib.org/reference/ids_with_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Get parsed IDs by token — ids_with_token","title":"Get parsed IDs by token — ids_with_token","text":"Gets source IDs (row indices) corresponding given token.","code":""},{"path":"https://lintr.r-lib.org/reference/ids_with_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get parsed IDs by token — ids_with_token","text":"","code":"ids_with_token(source_expression, value, fun = `==`, source_file)  with_id(source_expression, id, source_file)"},{"path":"https://lintr.r-lib.org/reference/ids_with_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get parsed IDs by token — ids_with_token","text":"source_expression list source expressions, result call get_source_expressions(), desired filename. value Character. String corresponding token search . example: \"SYMBOL\" \"FUNCTION\" \"EQ_FORMALS\" \"$\" \"(\" fun additional flexibility, function search token column parsed_content. Typically == %%. source_file (DEPRECATED) source_expression. removed. id Integer. index corresponding desired row parsed_content.","code":""},{"path":"https://lintr.r-lib.org/reference/ids_with_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get parsed IDs by token — ids_with_token","text":"ids_with_token: indices parsed_content data frame entry list source expressions. Indices correspond rows fun evaluates TRUE value token column. with_id: data frame corresponding row(s) specified id.","code":""},{"path":"https://lintr.r-lib.org/reference/ids_with_token.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get parsed IDs by token — ids_with_token","text":"with_id: Return row parsed_content entry [get_source_expressions]() object. Typically used conjunction ids_with_token iterate rows containing desired tokens.","code":""},{"path":"https://lintr.r-lib.org/reference/ifelse_censor_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block usage of ifelse where pmin or pmax is more appropriate — ifelse_censor_linter","title":"Block usage of ifelse where pmin or pmax is more appropriate — ifelse_censor_linter","text":"ifelse(x > M, M, x) pmin(x, M), harder read requires several passes vector.","code":""},{"path":"https://lintr.r-lib.org/reference/ifelse_censor_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block usage of ifelse where pmin or pmax is more appropriate — ifelse_censor_linter","text":"","code":"ifelse_censor_linter()"},{"path":"https://lintr.r-lib.org/reference/ifelse_censor_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Block usage of ifelse where pmin or pmax is more appropriate — ifelse_censor_linter","text":"goes similar ways censor vector, e.g. ifelse(x <= M, x, M) pmin(x, M), ifelse(x < m, m, x) pmax(x, m), ifelse(x >= m, x, m) pmax(x, m).","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/ifelse_censor_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block usage of ifelse where pmin or pmax is more appropriate — ifelse_censor_linter","text":"best_practices, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/implicit_integer_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Implicit integer linter — implicit_integer_linter","title":"Implicit integer linter — implicit_integer_linter","text":"Check integers explicitly typed using form 1L instead 1.","code":""},{"path":"https://lintr.r-lib.org/reference/implicit_integer_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Implicit integer linter — implicit_integer_linter","text":"","code":"implicit_integer_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/implicit_integer_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Implicit integer linter — implicit_integer_linter","text":"best_practices, consistency, style","code":""},{"path":"https://lintr.r-lib.org/reference/infix_spaces_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix spaces linter — infix_spaces_linter","title":"Infix spaces linter — infix_spaces_linter","text":"Check infix operators surrounded spaces. Enforces corresponding Tidyverse style guide rule; see https://style.tidyverse.org/syntax.html#infix-operators.","code":""},{"path":"https://lintr.r-lib.org/reference/infix_spaces_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix spaces linter — infix_spaces_linter","text":"","code":"infix_spaces_linter(exclude_operators = NULL, allow_multiple_spaces = TRUE)"},{"path":"https://lintr.r-lib.org/reference/infix_spaces_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix spaces linter — infix_spaces_linter","text":"exclude_operators Character vector operators exlude consideration linting. Default include following \"low-precedence\" operators: +, -, ~, >, >=, <, <=, ==, !=, &, &&, |, ||, <-, :=, <<-, ->, ->>, =, /, *, infix operator (exclude infixes passing \"%%\"). Note <-, :=, <<- included/excluded group (indicated passing \"<-\"), -> ->> (viz, \"->\"), = assignment setting arguments calls treated . allow_multiple_spaces Logical, default TRUE. FALSE, usage like x  =  2 also linted; excluded default usage can sometimes used better code alignment, allowed style guide.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/infix_spaces_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Infix spaces linter — infix_spaces_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/inner_combine_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require c() to be applied before relatively expensive vectorized functions — inner_combine_linter","title":"Require c() to be applied before relatively expensive vectorized functions — inner_combine_linter","text":".Date(c(, b)) logically equivalent c(.Date(), .Date(b)); ditto equivalence several vectorized functions like .POSIXct() math functions like sin(). former preferred expensive part operation (.Date()) applied .","code":""},{"path":"https://lintr.r-lib.org/reference/inner_combine_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require c() to be applied before relatively expensive vectorized functions — inner_combine_linter","text":"","code":"inner_combine_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/inner_combine_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require c() to be applied before relatively expensive vectorized functions — inner_combine_linter","text":"consistency, efficiency, readability","code":""},{"path":"https://lintr.r-lib.org/reference/is_lint_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Is this an expression- or a file-level source object? — is_lint_level","title":"Is this an expression- or a file-level source object? — is_lint_level","text":"Helper determining whether current source_expression contains expressions current file, just single expression.","code":""},{"path":"https://lintr.r-lib.org/reference/is_lint_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is this an expression- or a file-level source object? — is_lint_level","text":"","code":"is_lint_level(source_expression, level = c(\"expression\", \"file\"))"},{"path":"https://lintr.r-lib.org/reference/is_lint_level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is this an expression- or a file-level source object? — is_lint_level","text":"source_expression parsed expression object, .e., element object returned get_source_expressions(). level level expression tested? \"expression\" means individual expression, \"file\" means expressions current file available.","code":""},{"path":"https://lintr.r-lib.org/reference/line_length_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Line length linter — line_length_linter","title":"Line length linter — line_length_linter","text":"Check line length comments code less length.","code":""},{"path":"https://lintr.r-lib.org/reference/line_length_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Line length linter — line_length_linter","text":"","code":"line_length_linter(length = 80L)"},{"path":"https://lintr.r-lib.org/reference/line_length_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Line length linter — line_length_linter","text":"length maximum line length allowed.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/line_length_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Line length linter — line_length_linter","text":"configurable, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/lint-s3.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a lint object — lint-s3","title":"Create a lint object — lint-s3","text":"Create lint object","code":""},{"path":"https://lintr.r-lib.org/reference/lint-s3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a lint object — lint-s3","text":"","code":"Lint(   filename,   line_number = 1L,   column_number = 1L,   type = c(\"style\", \"warning\", \"error\"),   message = \"\",   line = \"\",   ranges = NULL,   linter = \"\" )"},{"path":"https://lintr.r-lib.org/reference/lint-s3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a lint object — lint-s3","text":"filename path source file linted. line_number line number lint occurred. column_number column number lint occurred. type type lint. message message used describe lint error line code source lint occurred ranges list ranges line emphasized. linter deprecated. longer used.","code":""},{"path":"https://lintr.r-lib.org/reference/lint-s3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a lint object — lint-s3","text":"object class 'lint'.","code":""},{"path":"https://lintr.r-lib.org/reference/lint.html","id":null,"dir":"Reference","previous_headings":"","what":"Lint a file, directory, or package — lint","title":"Lint a file, directory, or package — lint","text":"lint() lints single file. lint_dir() lints files directory. line_pakage() lints likely locations R files package, .e. R/, tests/, inst/, vignettes/, data-raw/, demo/.","code":""},{"path":"https://lintr.r-lib.org/reference/lint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lint a file, directory, or package — lint","text":"","code":"lint(   filename,   linters = NULL,   ...,   cache = FALSE,   parse_settings = TRUE,   text = NULL )  lint_dir(   path = \".\",   ...,   relative_path = TRUE,   exclusions = list(\"renv\", \"packrat\"),   pattern = rex::rex(\".\", one_of(\"Rr\"), or(\"\", \"html\", \"md\", \"nw\", \"rst\", \"tex\",     \"txt\"), end),   parse_settings = TRUE )  lint_package(   path = \".\",   ...,   relative_path = TRUE,   exclusions = list(\"R/RcppExports.R\"),   parse_settings = TRUE )"},{"path":"https://lintr.r-lib.org/reference/lint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lint a file, directory, or package — lint","text":"filename either filename file lint, character string inline R code linting. latter (inline data) applies whenever filename newline character (\\n). linters named list linter functions apply. See linters full list default available linters. ... additional arguments passed lint(), e.g. linters cache. cache given logical, toggle caching lint results. passed character string, store cache directory. parse_settings whether try parse settings. text Optional argument supplying string lines directly, e.g. file already memory linting done ad hoc. path base directory project (lint_dir()) package (lint_package()). relative_path TRUE, file paths printed using path relative base directory. FALSE, use full absolute path. exclusions exclusions exclude(), relative package path. pattern pattern files, default take files extensions .R, .Rmd, .Rnw, .Rhtml, .Rrst, .Rtex, .Rtxt allowing lowercase r (.r, ...)","code":""},{"path":"https://lintr.r-lib.org/reference/lint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lint a file, directory, or package — lint","text":"list lint objects.","code":""},{"path":"https://lintr.r-lib.org/reference/lint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lint a file, directory, or package — lint","text":"Read vigentte(\"lintr\") learn configure linters run default.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Available linters — linters","title":"Available linters — linters","text":"variety linters available lintr. popular ones readily accessible default_linters(). Within lint() function call, linters use initialized provided arguments fed source file (provided get_source_expressions()). data frame available linters can retrieved using available_linters(). Documentation linters structured tags allow easier discovery; see also available_tags().","code":""},{"path":"https://lintr.r-lib.org/reference/linters.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Available linters — linters","text":"following tags exist: best_practices (36 linters) common_mistakes (6 linters) configurable (19 linters) consistency (16 linters) correctness (7 linters) default (24 linters) deprecated (4 linters) efficiency (15 linters) package_development (14 linters) readability (36 linters) robustness (12 linters) style (35 linters)","code":""},{"path":"https://lintr.r-lib.org/reference/linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Available linters — linters","text":"following linters exist: absolute_path_linter (tags: best_practices, configurable, robustness) any_duplicated_linter (tags: best_practices, efficiency) any_is_na_linter (tags: best_practices, efficiency) assignment_linter (tags: consistency, default, style) backport_linter (tags: configurable, package_development, robustness) brace_linter (tags: configurable, default, readability, style) class_equals_linter (tags: best_practices, consistency, robustness) closed_curly_linter (tags: configurable, deprecated, readability, style) commas_linter (tags: default, readability, style) commented_code_linter (tags: best_practices, default, readability, style) condition_message_linter (tags: best_practices, consistency) conjunct_test_linter (tags: best_practices, package_development, readability) consecutive_stopifnot_linter (tags: consistency, readability, style) cyclocomp_linter (tags: best_practices, configurable, default, readability, style) duplicate_argument_linter (tags: common_mistakes, configurable, correctness) equals_na_linter (tags: common_mistakes, correctness, default, robustness) expect_comparison_linter (tags: best_practices, package_development) expect_identical_linter (tags: package_development) expect_length_linter (tags: best_practices, package_development, readability) expect_named_linter (tags: best_practices, package_development, readability) expect_not_linter (tags: best_practices, package_development, readability) expect_null_linter (tags: best_practices, package_development) expect_s3_class_linter (tags: best_practices, package_development) expect_s4_class_linter (tags: best_practices, package_development) expect_true_false_linter (tags: best_practices, package_development, readability) expect_type_linter (tags: best_practices, package_development) extraction_operator_linter (tags: best_practices, style) fixed_regex_linter (tags: best_practices, efficiency, readability) function_left_parentheses_linter (tags: default, readability, style) ifelse_censor_linter (tags: best_practices, efficiency) implicit_integer_linter (tags: best_practices, consistency, style) infix_spaces_linter (tags: default, readability, style) inner_combine_linter (tags: consistency, efficiency, readability) line_length_linter (tags: configurable, default, readability, style) literal_coercion_linter (tags: best_practices, consistency, efficiency) missing_argument_linter (tags: common_mistakes, configurable, correctness) missing_package_linter (tags: common_mistakes, robustness) namespace_linter (tags: configurable, correctness, robustness) nested_ifelse_linter (tags: efficiency, readability) no_tab_linter (tags: consistency, default, style) nonportable_path_linter (tags: best_practices, configurable, robustness) numeric_leading_zero_linter (tags: consistency, readability, style) object_length_linter (tags: configurable, default, readability, style) object_name_linter (tags: configurable, consistency, default, style) object_usage_linter (tags: correctness, default, readability, style) open_curly_linter (tags: configurable, deprecated, readability, style) outer_negation_linter (tags: best_practices, efficiency, readability) package_hooks_linter (tags: correctness, package_development, style) paren_body_linter (tags: default, readability, style) paren_brace_linter (tags: deprecated, readability, style) paste_linter (tags: best_practices, consistency) pipe_call_linter (tags: readability, style) pipe_continuation_linter (tags: default, readability, style) redundant_ifelse_linter (tags: best_practices, consistency, efficiency) regex_subset_linter (tags: best_practices, efficiency) semicolon_linter (tags: configurable, default, readability, style) semicolon_terminator_linter (tags: configurable, deprecated, readability, style) seq_linter (tags: best_practices, consistency, default, efficiency, robustness) single_quotes_linter (tags: consistency, default, readability, style) spaces_inside_linter (tags: default, readability, style) spaces_left_parentheses_linter (tags: default, readability, style) sprintf_linter (tags: common_mistakes, correctness) strings_as_factors_linter (tags: robustness) system_file_linter (tags: best_practices, consistency, readability) T_and_F_symbol_linter (tags: best_practices, consistency, default, readability, robustness, style) todo_comment_linter (tags: configurable, style) trailing_blank_lines_linter (tags: default, style) trailing_whitespace_linter (tags: default, style) undesirable_function_linter (tags: best_practices, configurable, efficiency, robustness, style) undesirable_operator_linter (tags: best_practices, configurable, efficiency, robustness, style) unneeded_concatenation_linter (tags: efficiency, readability, style) unreachable_code_linter (tags: best_practices, readability) unused_import_linter (tags: best_practices, common_mistakes, configurable) vector_logic_linter (tags: best_practices, default, efficiency) yoda_test_linter (tags: best_practices, package_development, readability)","code":""},{"path":"https://lintr.r-lib.org/reference/linters_with_defaults.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a linter configuration based on defaults — linters_with_defaults","title":"Create a linter configuration based on defaults — linters_with_defaults","text":"Make new list based lintr's default linters. result function meant passed linters argument lint(), put configuration file.","code":""},{"path":"https://lintr.r-lib.org/reference/linters_with_defaults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a linter configuration based on defaults — linters_with_defaults","text":"","code":"linters_with_defaults(..., defaults = default_linters)  with_defaults(..., default = default_linters)"},{"path":"https://lintr.r-lib.org/reference/linters_with_defaults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a linter configuration based on defaults — linters_with_defaults","text":"... Arguments elements change. unnamed, argument automatically named. named argument already exists list linters, replaced new element. exist, added. value NULL, linter removed. defaults, default Default list linters modify. Must named.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/linters_with_defaults.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a linter configuration based on defaults — linters_with_defaults","text":"","code":"# When using interactively you will usually pass the result onto `lint` or `lint_package()` if (FALSE) { lint(\"foo.R\", linters = linters_with_defaults(line_length_linter = line_length_linter(120))) } # the default linter list with a different line length cutoff my_linters <- linters_with_defaults(line_length_linter = line_length_linter(120))  # omit the argument name if you are just using different arguments my_linters <- linters_with_defaults(defaults = my_linters, object_name_linter(\"camelCase\"))  # remove assignment checks (with NULL), add absolute path checks my_linters <- linters_with_defaults(   defaults = my_linters,   assignment_linter = NULL,   absolute_path_linter() )"},{"path":"https://lintr.r-lib.org/reference/linters_with_tags.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a tag-based linter configuration — linters_with_tags","title":"Create a tag-based linter configuration — linters_with_tags","text":"Make new list based linters provided packages tagged tags. result function meant passed linters argument lint(), put configuration file.","code":""},{"path":"https://lintr.r-lib.org/reference/linters_with_tags.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a tag-based linter configuration — linters_with_tags","text":"","code":"linters_with_tags(tags, ..., packages = \"lintr\", exclude_tags = \"deprecated\")"},{"path":"https://lintr.r-lib.org/reference/linters_with_tags.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a tag-based linter configuration — linters_with_tags","text":"tags Optional character vector tags search. linters least one matching tag returned. tags NULL, linters returned. ... Arguments elements change. unnamed, argument automatically named. named argument already exists list linters, replaced new element. exist, added. value NULL, linter removed. packages character vector packages search linters. exclude_tags Tags exclude results. Linters least one matching tag returned. except_tags NULL, linters excluded.","code":""},{"path":"https://lintr.r-lib.org/reference/linters_with_tags.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a tag-based linter configuration — linters_with_tags","text":"modified list linters.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/linters_with_tags.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a tag-based linter configuration — linters_with_tags","text":"","code":"# `linters_with_defaults()` and `linters_with_tags(\"default\")` are the same: all.equal(linters_with_defaults(), linters_with_tags(\"default\")) #> [1] TRUE  # Get all linters useful for package development linters_with_tags(tags = \"package_development\") #> $backport_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     if (all(r_version >= R_system_version(names(backports)))) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     all_names_nodes <- xml2::xml_find_all(xml, names_xpath) #>     all_names <- xml2::xml_text(all_names_nodes) #>     needs_backport <- do.call(rbind, lapply(backport_blacklist,  #>         function(nm) all_names %in% nm)) #>     bad_idx <- colSums(needs_backport) > 0L #>     needs_backport_version_idx <- ((which(needs_backport) - 1L)%%length(backport_blacklist)) +  #>         1L #>     lint_message <- sprintf(\"%s (R %s) is not available for dependency R >= %s.\",  #>         all_names[bad_idx], names(backport_blacklist)[needs_backport_version_idx],  #>         r_version) #>     xml_nodes_to_lints(all_names_nodes[bad_idx], source_expression = source_expression,  #>         lint_message = lint_message, type = \"warning\") #> } #> <bytecode: 0x561eec95ee70> #> <environment: 0x561eec995e08> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"backport_linter\" #>  #> $conjunct_test_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     if (length(bad_expr) == 0L) { #>         return(list()) #>     } #>     matched_fun <- xp_call_name(bad_expr) #>     operator <- xml2::xml_find_chr(bad_expr, \"string(expr/*[self::AND2 or self::OR2])\") #>     replacement_fmt <- ifelse(matched_fun %in% c(\"expect_true\",  #>         \"expect_false\"), \"write multiple expectations like %1$s(A) and %1$s(B)\",  #>         \"write multiple conditions like %s(A, B).\") #>     lint_message <- paste(sprintf(\"Instead of %s(A %s B),\", matched_fun,  #>         operator), sprintf(replacement_fmt, matched_fun), \"The latter will produce better error messages in the case of failure.\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec967f10> #> <environment: 0x561eeca3d658> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"conjunct_test_linter\" #>  #> $expect_comparison_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     comparator <- xml2::xml_find_chr(bad_expr, \"string(expr[2]/*[2])\") #>     expectation <- comparator_expectation_map[comparator] #>     lint_message <- sprintf(\"%s(x, y) is better than expect_true(x %s y).\",  #>         expectation, comparator) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96be30> #> <environment: 0x561eecac9a58> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_comparison_linter\" #>  #> $expect_identical_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"Use expect_identical(x, y) by default; resort to expect_equal() only when needed,\",  #>             \"e.g. when setting ignore_attr= or tolerance=.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96d768> #> <environment: 0x561eecb60ac8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_identical_linter\" #>  #> $expect_length_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     lint_message <- sprintf(\"expect_length(x, n) is better than %s(length(x), n)\",  #>         matched_function) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96f538> #> <environment: 0x561eecc0cd28> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_length_linter\" #>  #> $expect_named_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr, depth = 0L) #>     lint_message <- sprintf(\"expect_named(x, n) is better than %s(names(x), n)\",  #>         matched_function) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message, type = \"warning\") #> } #> <bytecode: 0x561eec9710a0> #> <environment: 0x561eecc827f0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_named_linter\" #>  #> $expect_not_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"expect_false(x) is better than expect_true(!x), and vice versa.\",  #>         type = \"warning\") #> } #> <bytecode: 0x561eec972ee0> #> <environment: 0x561ee966fb70> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_not_linter\" #>  #> $expect_null_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr, depth = 0L) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_null(x) is better than %s(x, NULL)\",  #>             matched_function), \"expect_null(x) is better than expect_true(is.null(x))\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = msg,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec974c08> #> <environment: 0x561ee960a148> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_null_linter\" #>  #> $expect_s3_class_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_s3_class(x, k) is better than %s(class(x), k).\",  #>             matched_function), \"expect_s3_class(x, k) is better than expect_true(is.<k>(x)) or expect_true(inherits(x, k)).\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = paste(msg,  #>         \"Note also expect_s4_class() available for testing S4 objects.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97b9d0> #> <environment: 0x561ee95b0950> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_s3_class_linter\" #>  #> $expect_s4_class_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"expect_s4_class(x, k) is better than expect_true(is(x, k)).\",  #>             \"Note also expect_s3_class() available for testing S3 objects.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97d298> #> <environment: 0x561ee949d890> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_s4_class_linter\" #>  #> $expect_true_false_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     call_name <- xp_call_name(bad_expr, condition = \"starts-with(text(), 'expect_')\") #>     truth_value <- xml2::xml_find_chr(bad_expr, \"string(expr/NUM_CONST[text() = 'TRUE' or text() = 'FALSE'])\") #>     lint_message <- sprintf(\"expect_%s(x) is better than %s(x, %s)\",  #>         tolower(truth_value), call_name, truth_value) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97ed90> #> <environment: 0x561ee942c8f8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_true_false_linter\" #>  #> $expect_type_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_type(x, t) is better than %s(typeof(x), t)\",  #>             matched_function), \"expect_type(x, t) is better than expect_true(is.<t>(x))\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = msg,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec983b90> #> <environment: 0x561ee939f2c0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_type_linter\" #>  #> $package_hooks_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_msg_call_lints <- function(hook) { #>         xpath <- sprintf(bad_msg_call_xpath_fmt, hook, xp_text_in_table(bad_calls[[hook]])) #>         bad_expr <- xml2::xml_find_all(xml, xpath) #>         xml_nodes_to_lints(bad_expr, source_expression, make_bad_call_lint_msg(hook),  #>             type = \"warning\") #>     } #>     onload_bad_msg_call_lints <- bad_msg_call_lints(\".onLoad\") #>     onattach_bad_msg_call_lints <- bad_msg_call_lints(\".onAttach\") #>     load_arg_name_expr <- xml2::xml_find_all(xml, load_arg_name_xpath) #>     load_arg_name_message <- sprintf(\"%s() should take two arguments, with the first starting with 'lib' and the second starting with 'pkg'.\",  #>         xml2::xml_find_chr(load_arg_name_expr, hook_xpath)) #>     load_arg_name_lints <- xml_nodes_to_lints(load_arg_name_expr,  #>         source_expression, load_arg_name_message, type = \"warning\") #>     library_require_expr <- xml2::xml_find_all(xml, library_require_xpath) #>     library_require_bad_call <- xml2::xml_text(library_require_expr) #>     library_require_hook <- xml2::xml_find_chr(library_require_expr,  #>         hook_xpath) #>     library_require_message <- character(length(library_require_bad_call)) #>     is_installed_packages <- library_require_bad_call == \"installed.packages\" #>     library_require_message[is_installed_packages] <- sprintf(\"Don't slow down package load by running installed.packages() in %s().\",  #>         library_require_hook) #>     library_require_message[!is_installed_packages] <- sprintf(\"Don't alter the search() path in %s() by calling %s().\",  #>         library_require_hook, library_require_bad_call) #>     library_require_lints <- xml_nodes_to_lints(library_require_expr,  #>         source_expression, library_require_message, type = \"warning\") #>     bad_unload_call_expr <- xml2::xml_find_all(xml, bad_unload_call_xpath) #>     bad_unload_call_message <- sprintf(\"Use library.dynam.unload() calls in .onUnload(), not %s().\",  #>         xml2::xml_find_chr(bad_unload_call_expr, hook_xpath)) #>     bad_unload_call_lints <- xml_nodes_to_lints(bad_unload_call_expr,  #>         source_expression, bad_unload_call_message, type = \"warning\") #>     unload_arg_name_expr <- xml2::xml_find_all(xml, unload_arg_name_xpath) #>     unload_arg_name_message <- sprintf(\"%s() should take one argument starting with 'lib'.\",  #>         xml2::xml_find_chr(unload_arg_name_expr, hook_xpath)) #>     unload_arg_name_lints <- xml_nodes_to_lints(unload_arg_name_expr,  #>         source_expression, unload_arg_name_message, type = \"warning\") #>     return(c(onload_bad_msg_call_lints, onattach_bad_msg_call_lints,  #>         load_arg_name_lints, library_require_lints, bad_unload_call_lints,  #>         unload_arg_name_lints)) #> } #> <bytecode: 0x561eec988498> #> <environment: 0x561ee930b9e8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"package_hooks_linter\" #>  #> $yoda_test_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = function(expr) { #>             matched_call <- xp_call_name(expr) #>             second_const <- xml2::xml_find_first(expr, glue::glue(\"expr[position() = 3 and ({const_condition})]\")) #>             if (is.na(second_const)) { #>                 paste(\"Tests should compare objects in the order 'actual', 'expected', not the reverse.\",  #>                   sprintf(\"For example, do %1$s(foo(x), 2L) instead of %1$s(2L, foo(x)).\",  #>                     matched_call)) #>             } #>             else { #>                 sprintf(\"Avoid storing placeholder tests like %s(1, 1)\",  #>                   matched_call) #>             } #>         }, type = \"warning\") #> } #> <bytecode: 0x561eec9925e8> #> <environment: 0x561ee929ad38> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"yoda_test_linter\" #>   # Get all linters provided by lintr linters_with_tags(tags = NULL) #> $absolute_path_linter #> function (source_expression)  #> { #>     lapply(ids_with_token(source_expression, \"STR_CONST\"), function(id) { #>         token <- with_id(source_expression, id) #>         path <- get_r_string(token$text) #>         if (path_function(path)) { #>             start <- token[[\"col1\"]] + 1L #>             end <- token[[\"col2\"]] - 1L #>             Lint(filename = source_expression[[\"filename\"]],  #>                 line_number = token[[\"line1\"]], column_number = start,  #>                 type = \"warning\", message = message, line = source_expression[[\"lines\"]][[as.character(token[[\"line1\"]])]],  #>                 ranges = list(c(start, end))) #>         } #>     }) #> } #> <bytecode: 0x561ee7cd9560> #> <environment: 0x561ee8f69598> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"absolute_path_linter\" #>  #> $any_duplicated_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     any_duplicated_expr <- xml2::xml_find_all(xml, any_duplicated_xpath) #>     any_duplicated_lints <- xml_nodes_to_lints(any_duplicated_expr,  #>         source_expression = source_expression, lint_message = \"anyDuplicated(x, ...) > 0 is better than any(duplicated(x), ...).\",  #>         type = \"warning\") #>     length_unique_expr <- xml2::xml_find_all(xml, length_unique_xpath) #>     lint_message <- ifelse(is.na(xml2::xml_find_first(length_unique_expr,  #>         \"./parent::expr/expr/expr/SYMBOL_FUNCTION_CALL[text() = 'nrow']\")),  #>         \"anyDuplicated(x) == 0L is better than length(unique(x)) == length(x).\",  #>         \"anyDuplicated(DF$col) == 0L is better than length(unique(DF$col)) == nrow(DF)\") #>     length_unique_lints <- xml_nodes_to_lints(length_unique_expr,  #>         source_expression = source_expression, lint_message = lint_message,  #>         type = \"warning\") #>     return(c(any_duplicated_lints, length_unique_lints)) #> } #> <bytecode: 0x561ee90ce2b0> #> <environment: 0x561ee8e31128> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"any_duplicated_linter\" #>  #> $any_is_na_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"anyNA(x) is better than any(is.na(x)).\",  #>         type = \"warning\") #> } #> <bytecode: 0x561ee90c8fe0> #> <environment: 0x561ee8d5dd10> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"any_is_na_linter\" #>  #> $assignment_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     if (length(bad_expr) == 0L) { #>         return(list()) #>     } #>     operator <- xml2::xml_text(bad_expr) #>     lint_message_fmt <- ifelse(operator %in% c(\"<<-\", \"->>\"),  #>         \"%s can have hard-to-predict behavior; prefer assigning to a specific environment instead (with assign() or <-).\",  #>         \"Use <-, not %s, for assignment.\") #>     lint_message <- sprintf(lint_message_fmt, operator) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"style\") #> } #> <bytecode: 0x561eeba38860> #> <environment: 0x561ee8bb9298> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"assignment_linter\" #>  #> $backport_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     if (all(r_version >= R_system_version(names(backports)))) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     all_names_nodes <- xml2::xml_find_all(xml, names_xpath) #>     all_names <- xml2::xml_text(all_names_nodes) #>     needs_backport <- do.call(rbind, lapply(backport_blacklist,  #>         function(nm) all_names %in% nm)) #>     bad_idx <- colSums(needs_backport) > 0L #>     needs_backport_version_idx <- ((which(needs_backport) - 1L)%%length(backport_blacklist)) +  #>         1L #>     lint_message <- sprintf(\"%s (R %s) is not available for dependency R >= %s.\",  #>         all_names[bad_idx], names(backport_blacklist)[needs_backport_version_idx],  #>         r_version) #>     xml_nodes_to_lints(all_names_nodes[bad_idx], source_expression = source_expression,  #>         lint_message = lint_message, type = \"warning\") #> } #> <bytecode: 0x561eec95ee70> #> <environment: 0x561ee8adea70> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"backport_linter\" #>  #> $brace_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     lints <- list() #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_open_curly), source_expression = source_expression,  #>         lint_message = \"Opening curly braces should never go on their own line and should always be followed by a new line.\")) #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_paren_brace), source_expression = source_expression,  #>         lint_message = \"There should be a space before an opening curly brace.\")) #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_closed_curly), source_expression = source_expression,  #>         lint_message = \"Closing curly-braces should always be on their own line, unless they are followed by an else.\")) #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_else_same_line), source_expression = source_expression,  #>         lint_message = \"`else` should come on the same line as the previous `}`.\")) #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_function_brace), source_expression = source_expression,  #>         lint_message = \"Any function spanning multiple lines should use curly braces.\")) #>     lints <- c(lints, xml_nodes_to_lints(xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xp_if_else_match_brace), source_expression = source_expression,  #>         lint_message = \"Either both or neither branch in `if`/`else` should use curly braces.\")) #>     lints #> } #> <bytecode: 0x561eeba3f040> #> <environment: 0x561ee86312e0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"brace_linter\" #>  #> $class_equals_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     operator <- xml2::xml_find_chr(bad_expr, \"string(*[2])\") #>     lint_message <- sprintf(\"Instead of comparing class(x) with %s, use inherits(x, 'class-name') or is.<class> or is(x, 'class')\",  #>         operator) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = lint_message, type = \"warning\") #> } #> <bytecode: 0x561ee90c52f0> #> <environment: 0x561ee84d8d00> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"class_equals_linter\" #>  #> $commas_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     before_lints <- xml_nodes_to_lints(xml2::xml_find_all(xml,  #>         xpath_before), source_expression = source_expression,  #>         lint_message = \"Commas should never have a space before.\",  #>         range_start_xpath = \"number(./preceding-sibling::*[1]/@col2 + 1)\",  #>         range_end_xpath = \"number(./@col1 - 1)\") #>     after_lints <- xml_nodes_to_lints(xml2::xml_find_all(xml,  #>         xpath_after), source_expression = source_expression,  #>         lint_message = \"Commas should always have a space after.\",  #>         range_start_xpath = \"number(./@col2 + 1)\", range_end_xpath = \"number(./@col2 + 1)\") #>     c(before_lints, after_lints) #> } #> <bytecode: 0x561eeba42c88> #> <environment: 0x561ee8435760> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"commas_linter\" #>  #> $commented_code_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     all_comment_nodes <- xml2::xml_find_all(source_expression$full_xml_parsed_content,  #>         \"//COMMENT\") #>     all_comments <- xml2::xml_text(all_comment_nodes) #>     code_candidates <- re_matches(all_comments, code_candidate_regex,  #>         global = FALSE, locations = TRUE) #>     lapply(rownames(na.omit(code_candidates)), function(code_candidate) { #>         is_parsable <- parsable(code_candidates[code_candidate,  #>             \"code\"]) #>         if (is_parsable) { #>             comment_node <- all_comment_nodes[[as.integer(code_candidate)]] #>             line_number <- as.integer(xml2::xml_attr(comment_node,  #>                 \"line1\")) #>             column_offset <- as.integer(xml2::xml_attr(comment_node,  #>                 \"col1\")) - 1L #>             column_number <- column_offset + code_candidates[code_candidate,  #>                 \"code.start\"] #>             Lint(filename = source_expression$filename, line_number = line_number,  #>                 column_number = column_number, type = \"style\",  #>                 message = \"Commented code should be removed.\",  #>                 line = source_expression$file_lines[line_number],  #>                 ranges = list(c(column_number, column_offset +  #>                   code_candidates[code_candidate, \"code.end\"]))) #>         } #>     }) #> } #> <bytecode: 0x561eeba46240> #> <environment: 0x561ee831a1f8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"commented_code_linter\" #>  #> $condition_message_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     sep_value <- get_r_string(bad_expr, xpath = \"./expr/SYMBOL_SUB[text() = 'sep']/following-sibling::expr/STR_CONST\") #>     bad_expr <- bad_expr[is.na(sep_value) | sep_value %in% c(\"\",  #>         \" \")] #>     outer_call <- xp_call_name(bad_expr) #>     inner_call <- xp_call_name(bad_expr, depth = 2L) #>     lint_message <- paste(\"Don't use\", inner_call, \"to build\",  #>         outer_call, \"strings.\", \"Instead use the fact that these functions build condition message strings from their input\",  #>         \"(using \\\"\\\" as a separator). For translateable strings, prefer using gettextf().\") #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = lint_message, type = \"warning\") #> } #> <bytecode: 0x561ee90bdc20> #> <environment: 0x561ee80e00b0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"condition_message_linter\" #>  #> $conjunct_test_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     if (length(bad_expr) == 0L) { #>         return(list()) #>     } #>     matched_fun <- xp_call_name(bad_expr) #>     operator <- xml2::xml_find_chr(bad_expr, \"string(expr/*[self::AND2 or self::OR2])\") #>     replacement_fmt <- ifelse(matched_fun %in% c(\"expect_true\",  #>         \"expect_false\"), \"write multiple expectations like %1$s(A) and %1$s(B)\",  #>         \"write multiple conditions like %s(A, B).\") #>     lint_message <- paste(sprintf(\"Instead of %s(A %s B),\", matched_fun,  #>         operator), sprintf(replacement_fmt, matched_fun), \"The latter will produce better error messages in the case of failure.\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec967f10> #> <environment: 0x561ee8052ef8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"conjunct_test_linter\" #>  #> $consecutive_stopifnot_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"Unify consecutive calls to stopifnot().\",  #>         type = \"warning\") #> } #> <bytecode: 0x561ee90b9980> #> <environment: 0x561ee7f5c320> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"consecutive_stopifnot_linter\" #>  #> $cyclocomp_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     complexity <- try_silently(cyclocomp::cyclocomp(parse(text = source_expression$content))) #>     if (inherits(complexity, \"try-error\") || complexity <= complexity_limit) { #>         return(list()) #>     } #>     col1 <- source_expression[[\"column\"]][1L] #>     Lint(filename = source_expression[[\"filename\"]], line_number = source_expression[[\"line\"]][1L],  #>         column_number = source_expression[[\"column\"]][1L], type = \"style\",  #>         message = sprintf(\"Functions should have cyclomatic complexity of less than %d, this has %d.\",  #>             complexity_limit, complexity), ranges = list(rep(col1,  #>             2L)), line = source_expression$lines[1L]) #> } #> <bytecode: 0x561eeba4e0b8> #> <environment: 0x561ee7e94390> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"cyclocomp_linter\" #>  #> $duplicate_argument_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     xpath <- \"//expr[EQ_SUB]\" #>     calls <- xml2::xml_find_all(xml, xpath) #>     if (length(except)) { #>         calls_text <- get_r_string(calls, xpath = \"expr[1][count(*)=1]/*[1]\") #>         calls <- calls[!(calls_text %in% except)] #>     } #>     result <- lapply(calls, function(call) { #>         args <- xml2::xml_find_all(call, \"EQ_SUB/preceding-sibling::*[1]\") #>         args_text <- get_r_string(args) #>         is_dup_arg <- duplicated(args_text) #>         dup_args <- args[is_dup_arg] #>         if (length(dup_args)) { #>             line1 <- as.integer(xml2::xml_attr(dup_args, \"line1\")) #>             line2 <- as.integer(xml2::xml_attr(dup_args, \"line2\")) #>             col1 <- as.integer(xml2::xml_attr(dup_args, \"col1\")) #>             col2 <- as.integer(xml2::xml_attr(dup_args, \"col2\")) #>             col2[line2 > line1] <- nchar(source_expression$file_lines[line1[line2 >  #>                 line1]]) #>             lapply(seq_along(dup_args), function(i) { #>                 Lint(filename = source_expression$filename, line_number = line1[[i]],  #>                   column_number = col1[[i]], type = \"warning\",  #>                   message = \"Duplicate arguments in function call.\",  #>                   line = source_expression$file_lines[line1[[i]]],  #>                   ranges = list(c(col1[[i]], col2[[i]]))) #>             }) #>         } #>     }) #>     unlist(result, recursive = FALSE, use.names = FALSE) #> } #> <bytecode: 0x561ee90b6da0> #> <environment: 0x561ee7e12d20> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"duplicate_argument_linter\" #>  #> $equals_na_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = \"Use is.na for comparisons to NA (not == or !=)\",  #>         type = \"warning\") #> } #> <bytecode: 0x561eeba526a0> #> <environment: 0x561ee7d0b170> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"equals_na_linter\" #>  #> $expect_comparison_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     comparator <- xml2::xml_find_chr(bad_expr, \"string(expr[2]/*[2])\") #>     expectation <- comparator_expectation_map[comparator] #>     lint_message <- sprintf(\"%s(x, y) is better than expect_true(x %s y).\",  #>         expectation, comparator) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96be30> #> <environment: 0x561ee7b15750> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_comparison_linter\" #>  #> $expect_identical_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"Use expect_identical(x, y) by default; resort to expect_equal() only when needed,\",  #>             \"e.g. when setting ignore_attr= or tolerance=.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96d768> #> <environment: 0x561ee7a17f58> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_identical_linter\" #>  #> $expect_length_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     lint_message <- sprintf(\"expect_length(x, n) is better than %s(length(x), n)\",  #>         matched_function) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec96f538> #> <environment: 0x561ee7964e80> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_length_linter\" #>  #> $expect_named_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr, depth = 0L) #>     lint_message <- sprintf(\"expect_named(x, n) is better than %s(names(x), n)\",  #>         matched_function) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message, type = \"warning\") #> } #> <bytecode: 0x561eec9710a0> #> <environment: 0x561ee78d3560> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_named_linter\" #>  #> $expect_not_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"expect_false(x) is better than expect_true(!x), and vice versa.\",  #>         type = \"warning\") #> } #> <bytecode: 0x561eec972ee0> #> <environment: 0x561ee733c668> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_not_linter\" #>  #> $expect_null_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr, depth = 0L) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_null(x) is better than %s(x, NULL)\",  #>             matched_function), \"expect_null(x) is better than expect_true(is.null(x))\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = msg,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec974c08> #> <environment: 0x561ee6de2b60> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_null_linter\" #>  #> $expect_s3_class_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_s3_class(x, k) is better than %s(class(x), k).\",  #>             matched_function), \"expect_s3_class(x, k) is better than expect_true(is.<k>(x)) or expect_true(inherits(x, k)).\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = paste(msg,  #>         \"Note also expect_s4_class() available for testing S4 objects.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97b9d0> #> <environment: 0x561ee6cdae90> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_s3_class_linter\" #>  #> $expect_s4_class_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"expect_s4_class(x, k) is better than expect_true(is(x, k)).\",  #>             \"Note also expect_s3_class() available for testing S3 objects.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97d298> #> <environment: 0x561ee6b08000> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_s4_class_linter\" #>  #> $expect_true_false_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     call_name <- xp_call_name(bad_expr, condition = \"starts-with(text(), 'expect_')\") #>     truth_value <- xml2::xml_find_chr(bad_expr, \"string(expr/NUM_CONST[text() = 'TRUE' or text() = 'FALSE'])\") #>     lint_message <- sprintf(\"expect_%s(x) is better than %s(x, %s)\",  #>         tolower(truth_value), call_name, truth_value) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec97ed90> #> <environment: 0x561ee6930700> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_true_false_linter\" #>  #> $expect_type_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_function <- xp_call_name(bad_expr) #>     msg <- ifelse(matched_function %in% c(\"expect_equal\", \"expect_identical\"),  #>         sprintf(\"expect_type(x, t) is better than %s(typeof(x), t)\",  #>             matched_function), \"expect_type(x, t) is better than expect_true(is.<t>(x))\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message = msg,  #>         type = \"warning\") #> } #> <bytecode: 0x561eec983b90> #> <environment: 0x561ee6737dd8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"expect_type_linter\" #>  #> $extraction_operator_linter #> function (source_expression)  #> { #>     tokens <- source_expression[[\"parsed_content\"]] <- filter_out_token_type(source_expression[[\"parsed_content\"]],  #>         \"expr\") #>     lapply(ids_with_token(source_expression, c(\"'$'\", \"'['\"),  #>         fun = `%in%`), function(token_num) { #>         if (is_dollar_extract(token_num, tokens) || is_bracket_extract(token_num,  #>             tokens)) { #>             token <- with_id(source_expression, token_num) #>             start_col_num <- token[[\"col1\"]] #>             end_col_num <- token[[\"col2\"]] #>             line_num <- token[[\"line1\"]] #>             line <- source_expression[[\"lines\"]][[as.character(line_num)]] #>             Lint(filename = source_expression[[\"filename\"]],  #>                 line_number = line_num, column_number = start_col_num,  #>                 type = \"warning\", message = sprintf(\"Use `[[` instead of `%s` to extract an element.\",  #>                   token[[\"text\"]]), line = line, ranges = list(c(start_col_num,  #>                   end_col_num))) #>         } #>     }) #> } #> <bytecode: 0x561ee90a1c20> #> <environment: 0x561ee6536a40> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"extraction_operator_linter\" #>  #> $fixed_regex_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     patterns <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(patterns[is_not_regex(xml2::xml_text(patterns))],  #>         source_expression = source_expression, lint_message = paste(\"For static regular expression patterns, set `fixed = TRUE`.\",  #>             \"Note that this includes regular expressions that can be expressed as\",  #>             \"fixed patterns, e.g. [.] is really just . and \\\\$ is really just $\",  #>             \"if there are no other regular expression specials. For functions from\",  #>             \"the 'stringr' package, the way to declare a static string is to\",  #>             \"wrap the pattern in stringr::fixed().\", \"If this is being used in a dbplyr context (i.e., translated to sql),\",  #>             \"replace the regular expression with the `LIKE` operator using the\",  #>             \"`%LIKE%` infix function.\", \"Lastly, take care to remember that the `replacement` argument of\",  #>             \"`gsub()` is affected by the `fixed` argument as well.\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561ee909f820> #> <environment: 0x561ee5f8e090> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"fixed_regex_linter\" #>  #> $function_left_parentheses_linter #> function (source_expression)  #> { #>     lapply(ids_with_token(source_expression, \"'('\"), function(id) { #>         parsed <- source_expression$parsed_content[id, ] #>         terminal_tokens_before <- source_expression$parsed_content$line1 ==  #>             parsed$line1 & source_expression$parsed_content$col1 <  #>             parsed$col1 & source_expression$parsed_content$terminal #>         last_type <- tail(source_expression$parsed_content$token[terminal_tokens_before],  #>             n = 1L) #>         is_function_call <- length(last_type) %!=% 0L && (last_type %in%  #>             c(\"SYMBOL_FUNCTION_CALL\", \"FUNCTION\", \"'}'\", \"']'\")) #>         if (is_function_call) { #>             line <- source_expression$lines[as.character(parsed$line1)] #>             before_operator <- substr(line, parsed$col1 - 1L,  #>                 parsed$col1 - 1L) #>             space_before <- re_matches(before_operator, rex(space)) #>             if (space_before) { #>                 Lint(filename = source_expression$filename, line_number = parsed$line1,  #>                   column_number = parsed$col1, type = \"style\",  #>                   message = \"Remove spaces before the left parenthesis in a function call.\",  #>                   line = line) #>             } #>         } #>     }) #> } #> <bytecode: 0x561eeba52c28> #> <environment: 0x561ee4a7a088> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"function_left_parentheses_linter\" #>  #> $ifelse_censor_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_call <- xp_call_name(bad_expr) #>     operator <- xml2::xml_find_chr(bad_expr, \"string(expr[2]/*[2])\") #>     match_first <- !is.na(xml2::xml_find_first(bad_expr, \"expr[2][expr[1] = following-sibling::expr[1]]\")) #>     optimizer <- ifelse((operator %in% c(\"<\", \"<=\")) == match_first,  #>         \"pmin\", \"pmax\") #>     first_var <- rep_len(\"x\", length(match_first)) #>     second_var <- rep_len(\"y\", length(match_first)) #>     first_var[!match_first] <- \"y\" #>     second_var[!match_first] <- \"x\" #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = sprintf(\"%s(x, y) is preferable to %s(x %s y, %s, %s).\",  #>             optimizer, matched_call, operator, first_var, second_var),  #>         type = \"warning\") #> } #> <bytecode: 0x561ee9099270> #> <environment: 0x561ee5413ba0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"ifelse_censor_linter\" #>  #> $implicit_integer_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     numbers <- xml2::xml_find_all(xml, \"//NUM_CONST\") #>     xml_nodes_to_lints(numbers[is_implicit_integer(xml2::xml_text(numbers))],  #>         source_expression = source_expression, lint_message = \"Integers should not be implicit. Use the form 1L for integers or 1.0 for doubles.\",  #>         type = \"style\", column_number_xpath = \"number(./@col2 + 1)\",  #>         range_end_xpath = \"number(./@col2 + 1)\") #> } #> <bytecode: 0x561ee9072198> #> <environment: 0x561ee58fd580> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"implicit_integer_linter\" #>  #> $infix_spaces_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = lint_message, type = \"style\") #> } #> <bytecode: 0x561eeba5d4e8> #> <environment: 0x561ee44f08b0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"infix_spaces_linter\" #>  #> $inner_combine_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_call <- xp_call_name(bad_expr, depth = 2L) #>     lint_message <- paste(\"Combine inputs to vectorized functions first to take full advantage of vectorization, e.g.,\",  #>         sprintf(\"%1$s(c(x, y)) only runs the more expensive %1$s() once as compared to c(%1$s(x), %1$s(y)).\",  #>             matched_call)) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message, type = \"warning\") #> } #> <bytecode: 0x561ee9060dd8> #> <environment: 0x561ee96ec3a8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"inner_combine_linter\" #>  #> $line_length_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     line_lengths <- nchar(source_expression$file_lines) #>     long_lines <- which(line_lengths > length) #>     lint_message <- sprintf(\"Lines should not be more than %d characters.\",  #>         length) #>     lapply(long_lines, function(long_line) { #>         Lint(filename = source_expression$filename, line_number = long_line,  #>             column_number = length + 1L, type = \"style\", message = lint_message,  #>             line = source_expression$file_lines[long_line], ranges = list(c(1L,  #>                 line_lengths[long_line]))) #>     }) #> } #> <bytecode: 0x561eecde5168> #> <environment: 0x561eea675a68> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"line_length_linter\" #>  #> $literal_coercion_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"Use literals directly where possible, instead of coercion.\",  #>             \"c.f. 1L instead of as.integer(1), or NA_real_ instead of as.numeric(NA).\"),  #>         type = \"warning\") #> } #> <bytecode: 0x561ee9047b30> #> <environment: 0x561eea79a6f8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"literal_coercion_linter\" #>  #> $missing_argument_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     missing_args <- xml2::xml_find_all(xml, xpath) #>     line1 <- as.integer(xml2::xml_attr(missing_args, \"line1\")) #>     col1 <- as.integer(xml2::xml_attr(missing_args, \"col1\")) #>     col2 <- as.integer(xml2::xml_attr(missing_args, \"col2\")) #>     result <- lapply(seq_along(missing_args), function(i) { #>         func <- xml2::xml_find_all(missing_args[[i]], \"preceding-sibling::expr/SYMBOL_FUNCTION_CALL\") #>         func <- xml2::xml_text(func) #>         if (length(func) == 1L && !(func %in% except)) { #>             Lint(filename = source_expression$filename, line_number = line1[[i]],  #>                 column_number = col1[[i]], type = \"warning\",  #>                 message = \"Missing argument in function call.\",  #>                 line = source_expression$file_lines[[line1[[i]]]],  #>                 ranges = list(c(col1[[i]], col2[[i]]))) #>         } #>     }) #>     result[vapply(result, is.list, logical(1L))] #> } #> <bytecode: 0x561ee903aad8> #> <environment: 0x561eea805db0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"missing_argument_linter\" #>  #> $missing_package_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     pkg_calls <- xml2::xml_find_all(xml, call_xpath) #>     pkg_names <- get_r_string(xml2::xml_find_all(pkg_calls, \"OP-LEFT-PAREN[1]/following-sibling::expr[1][SYMBOL | STR_CONST]\")) #>     installed_packges <- .packages(all.available = TRUE) #>     missing_ids <- which(!(pkg_names %in% installed_packges)) #>     line1 <- as.integer(xml2::xml_attr(pkg_calls, \"line1\")) #>     col1 <- as.integer(xml2::xml_attr(pkg_calls, \"col1\")) #>     col2 <- as.integer(xml2::xml_attr(pkg_calls, \"col2\")) #>     lapply(missing_ids, function(i) { #>         Lint(filename = source_expression$filename, line_number = line1[[i]],  #>             column_number = col1[[i]], type = \"warning\", message = sprintf(\"Package '%s' is not installed.\",  #>                 pkg_names[[i]]), line = source_expression$file_lines[[line1[[i]]]],  #>             ranges = list(c(col1[[i]], col2[[i]]))) #>     }) #> } #> <bytecode: 0x561ee9033788> #> <environment: 0x561eea95deb0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"missing_package_linter\" #>  #> $namespace_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     ns_nodes <- xml2::xml_find_all(xml, \"//NS_GET | //NS_GET_INT\") #>     if (length(ns_nodes) == 0L) { #>         return(list()) #>     } #>     package_nodes <- xml2::xml_find_all(ns_nodes, \"preceding-sibling::*[1]\") #>     packages <- get_r_string(package_nodes) #>     lints <- list() #>     installed_packages <- .packages(all.available = TRUE) #>     installed <- packages %in% installed_packages #>     if (!all(installed)) { #>         lints <- c(lints, xml_nodes_to_lints(package_nodes[!installed],  #>             source_expression = source_expression, lint_message = sprintf(\"Package '%s' is not installed.\",  #>                 packages[!installed]), type = \"warning\")) #>         ns_nodes <- ns_nodes[installed] #>         packages <- packages[installed] #>         package_nodes <- package_nodes[installed] #>     } #>     if (!check_exports && !check_nonexports) { #>         return(lints) #>     } #>     namespaces <- lapply(packages, function(package) tryCatch(getNamespace(package),  #>         error = identity)) #>     failed_namespace <- vapply(namespaces, inherits, \"condition\",  #>         FUN.VALUE = logical(1L)) #>     if (any(failed_namespace)) { #>         lints <- c(lints, xml_nodes_to_lints(package_nodes[failed_namespace],  #>             source_expression = source_expression, lint_message = vapply(namespaces[failed_namespace],  #>                 conditionMessage, character(1L)), type = \"warning\")) #>         ns_nodes <- ns_nodes[!failed_namespace] #>         packages <- packages[!failed_namespace] #>         namespaces <- namespaces[!failed_namespace] #>     } #>     ns_get <- xml2::xml_text(ns_nodes) == \"::\" #>     symbol_nodes <- xml2::xml_find_all(ns_nodes, \"following-sibling::*[1]\") #>     symbols <- get_r_string(symbol_nodes) #>     if (check_nonexports) { #>         lints <- c(lints, build_ns_get_int_lints(packages[!ns_get],  #>             symbols[!ns_get], symbol_nodes[!ns_get], namespaces[!ns_get],  #>             source_expression)) #>     } #>     if (check_exports) { #>         lints <- c(lints, build_ns_get_lints(packages[ns_get],  #>             symbols[ns_get], symbol_nodes[ns_get], namespaces[ns_get],  #>             source_expression)) #>     } #>     lints #> } #> <bytecode: 0x561ee9025980> #> <environment: 0x561eea9bd328> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"namespace_linter\" #>  #> $nested_ifelse_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_call <- xp_call_name(bad_expr) #>     lint_message <- paste(sprintf(\"Don't use nested %s() calls;\",  #>         matched_call), \"instead, try (1) data.table::fcase; (2) dplyr::case_when; or (3) using a lookup table.\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561ee9019e50> #> <environment: 0x561eeaa23790> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"nested_ifelse_linter\" #>  #> $no_tab_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     all_matches <- re_matches(source_expression[[\"lines\"]], regex,  #>         locations = TRUE, global = TRUE) #>     line_numbers <- as.integer(names(source_expression[[\"lines\"]])) #>     lints <- Map(function(line_matches, line_number) { #>         lapply(split(line_matches, seq_len(nrow(line_matches))),  #>             function(.match) { #>                 if (is.na(.match[[\"start\"]]) || .in_ignorable_position(source_expression,  #>                   line_number, .match)) { #>                   return() #>                 } #>                 start <- .match[[\"start\"]] #>                 end <- .match[[\"end\"]] #>                 Lint(filename = source_expression[[\"filename\"]],  #>                   line_number = line_number, column_number = start,  #>                   type = lint_type, message = lint_msg, line = source_expression[[\"lines\"]][[as.character(line_number)]],  #>                   ranges = list(c(start, end))) #>             }) #>     }, all_matches, line_numbers) #>     Filter(function(x) any(lengths(x) > 0L), lints) #> } #> <bytecode: 0x561eeba61da8> #> <environment: 0x561eeaa9b960> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"no_tab_linter\" #>  #> $nonportable_path_linter #> function (source_expression)  #> { #>     lapply(ids_with_token(source_expression, \"STR_CONST\"), function(id) { #>         token <- with_id(source_expression, id) #>         path <- get_r_string(token$text) #>         if (path_function(path)) { #>             start <- token[[\"col1\"]] + 1L #>             end <- token[[\"col2\"]] - 1L #>             Lint(filename = source_expression[[\"filename\"]],  #>                 line_number = token[[\"line1\"]], column_number = start,  #>                 type = \"warning\", message = message, line = source_expression[[\"lines\"]][[as.character(token[[\"line1\"]])]],  #>                 ranges = list(c(start, end))) #>         } #>     }) #> } #> <bytecode: 0x561ee7cd9560> #> <environment: 0x561eeaafac18> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"nonportable_path_linter\" #>  #> $numeric_leading_zero_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"Include the leading zero for fractional numeric constants.\",  #>         type = \"warning\") #> } #> <bytecode: 0x561ee9010160> #> <environment: 0x561eeab5c020> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"numeric_leading_zero_linter\" #>  #> $object_length_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     assignments <- xml2::xml_find_all(xml, object_name_xpath) #>     nms <- strip_names(xml2::xml_text(assignments)) #>     ns_imports <- namespace_imports(find_package(source_expression$filename)) #>     generics <- strip_names(c(declared_s3_generics(xml), imported_s3_generics(ns_imports)$fun,  #>         .base_s3_generics)) #>     generics <- unique(generics[nzchar(generics)]) #>     nms_stripped <- re_substitutes(nms, rex(start, or(generics),  #>         \".\"), \"\") #>     too_long <- nchar(nms_stripped) > length #>     xml_nodes_to_lints(assignments[too_long], source_expression = source_expression,  #>         lint_message = lint_message, type = \"style\") #> } #> <bytecode: 0x561eeba66988> #> <environment: 0x561eeabbf268> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"object_length_linter\" #>  #> $object_name_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     assignments <- xml2::xml_find_all(xml, object_name_xpath) #>     nms <- strip_names(xml2::xml_text(assignments)) #>     generics <- c(declared_s3_generics(xml), imported_s3_generics(namespace_imports(find_package(source_expression$filename)))$fun,  #>         .base_s3_generics) #>     generics <- unique(generics[nzchar(generics)]) #>     style_matches <- lapply(styles, function(style) { #>         check_style(nms, style, generics) #>     }) #>     matches_a_style <- Reduce(`|`, style_matches) #>     xml_nodes_to_lints(assignments[!matches_a_style], source_expression,  #>         lint_message = lint_message, type = \"style\") #> } #> <bytecode: 0x561ee965dcf8> #> <environment: 0x561eeac201d8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"object_name_linter\" #>  #> $object_usage_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     pkg_name <- pkg_name(find_package(dirname(source_expression$filename))) #>     env <- make_check_env(pkg_name) #>     declared_globals <- try_silently(utils::globalVariables(package = pkg_name %||%  #>         globalenv())) #>     symbols <- c(get_assignment_symbols(source_expression$full_xml_parsed_content),  #>         get_imported_symbols(source_expression$full_xml_parsed_content)) #>     for (symbol in symbols) { #>         assign(symbol, function(...) invisible(), envir = env) #>     } #>     fun_info <- get_function_assignments(source_expression$full_xml_parsed_content) #>     lapply(seq_len(NROW(fun_info)), function(i) { #>         info <- fun_info[i, ] #>         code <- get_content(lines = source_expression$content[seq(info$line1,  #>             info$line2)], info) #>         fun <- try_silently(eval(envir = env, parse(text = code,  #>             keep.source = TRUE))) #>         if (inherits(fun, \"try-error\")) { #>             return() #>         } #>         known_used_symbols <- get_used_symbols(info$expr[[1L]],  #>             interpret_glue = interpret_glue) #>         res <- parse_check_usage(fun, known_used_symbols = known_used_symbols,  #>             declared_globals = declared_globals) #>         lapply(which(!is.na(res$message)), function(row_num) { #>             row <- res[row_num, ] #>             org_line_num <- as.integer(row$line1) + info$line1 -  #>                 1L #>             line <- source_expression$content[as.integer(org_line_num)] #>             row$name <- re_substitutes(row$name, rex(\"<-\"), \"\") #>             location <- re_matches(line, rex(boundary, row$name,  #>                 boundary), locations = TRUE) #>             if (is.na(location$start) && nzchar(row$line2) &&  #>                 row$line2 != row$line1) { #>                 lines <- source_expression$content[org_line_num:(as.integer(row$line2) +  #>                   info$line1 - 1L)] #>                 locations <- re_matches(lines, rex(boundary,  #>                   row$name, boundary), locations = TRUE) #>                 matching_row <- (which(!is.na(locations$start)) %||%  #>                   1L)[[1L]] #>                 org_line_num <- org_line_num + matching_row -  #>                   1L #>                 location <- locations[matching_row, ] #>                 line <- lines[matching_row] #>             } #>             if (is.na(location$start)) { #>                 location$start <- 1L #>                 location$end <- nchar(line) #>             } #>             Lint(filename = source_expression$filename, line_number = org_line_num,  #>                 column_number = location$start, type = \"warning\",  #>                 message = row$message, line = line, ranges = list(c(location$start,  #>                   location$end))) #>         }) #>     }) #> } #> <bytecode: 0x561eeba73440> #> <environment: 0x561eeac85848> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"object_usage_linter\" #>  #> $outer_negation_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     matched_call <- xp_call_name(bad_expr) #>     inverse_call <- ifelse(matched_call == \"any\", \"all\", \"any\") #>     lint_message <- paste(sprintf(\"!%s(x) is better than %s(!x).\",  #>         inverse_call, matched_call), \"The former applies negation only once after aggregation instead of many times for each element of x.\") #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561ee900f4d8> #> <environment: 0x561eeace6e38> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"outer_negation_linter\" #>  #> $package_hooks_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_msg_call_lints <- function(hook) { #>         xpath <- sprintf(bad_msg_call_xpath_fmt, hook, xp_text_in_table(bad_calls[[hook]])) #>         bad_expr <- xml2::xml_find_all(xml, xpath) #>         xml_nodes_to_lints(bad_expr, source_expression, make_bad_call_lint_msg(hook),  #>             type = \"warning\") #>     } #>     onload_bad_msg_call_lints <- bad_msg_call_lints(\".onLoad\") #>     onattach_bad_msg_call_lints <- bad_msg_call_lints(\".onAttach\") #>     load_arg_name_expr <- xml2::xml_find_all(xml, load_arg_name_xpath) #>     load_arg_name_message <- sprintf(\"%s() should take two arguments, with the first starting with 'lib' and the second starting with 'pkg'.\",  #>         xml2::xml_find_chr(load_arg_name_expr, hook_xpath)) #>     load_arg_name_lints <- xml_nodes_to_lints(load_arg_name_expr,  #>         source_expression, load_arg_name_message, type = \"warning\") #>     library_require_expr <- xml2::xml_find_all(xml, library_require_xpath) #>     library_require_bad_call <- xml2::xml_text(library_require_expr) #>     library_require_hook <- xml2::xml_find_chr(library_require_expr,  #>         hook_xpath) #>     library_require_message <- character(length(library_require_bad_call)) #>     is_installed_packages <- library_require_bad_call == \"installed.packages\" #>     library_require_message[is_installed_packages] <- sprintf(\"Don't slow down package load by running installed.packages() in %s().\",  #>         library_require_hook) #>     library_require_message[!is_installed_packages] <- sprintf(\"Don't alter the search() path in %s() by calling %s().\",  #>         library_require_hook, library_require_bad_call) #>     library_require_lints <- xml_nodes_to_lints(library_require_expr,  #>         source_expression, library_require_message, type = \"warning\") #>     bad_unload_call_expr <- xml2::xml_find_all(xml, bad_unload_call_xpath) #>     bad_unload_call_message <- sprintf(\"Use library.dynam.unload() calls in .onUnload(), not %s().\",  #>         xml2::xml_find_chr(bad_unload_call_expr, hook_xpath)) #>     bad_unload_call_lints <- xml_nodes_to_lints(bad_unload_call_expr,  #>         source_expression, bad_unload_call_message, type = \"warning\") #>     unload_arg_name_expr <- xml2::xml_find_all(xml, unload_arg_name_xpath) #>     unload_arg_name_message <- sprintf(\"%s() should take one argument starting with 'lib'.\",  #>         xml2::xml_find_chr(unload_arg_name_expr, hook_xpath)) #>     unload_arg_name_lints <- xml_nodes_to_lints(unload_arg_name_expr,  #>         source_expression, unload_arg_name_message, type = \"warning\") #>     return(c(onload_bad_msg_call_lints, onattach_bad_msg_call_lints,  #>         load_arg_name_lints, library_require_lints, bad_unload_call_lints,  #>         unload_arg_name_lints)) #> } #> <bytecode: 0x561eec988498> #> <environment: 0x561eead482e8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"package_hooks_linter\" #>  #> $paren_body_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     matched_expressions <- xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xpath) #>     xml_nodes_to_lints(matched_expressions, source_expression = source_expression,  #>         lint_message = \"There should be a space between right parenthesis and a body expression.\") #> } #> <bytecode: 0x561eeba87130> #> <environment: 0x561eeadaf5b0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"paren_body_linter\" #>  #> $paste_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     lints <- list() #>     if (!allow_empty_sep) { #>         empty_sep_expr <- xml2::xml_find_all(xml, sep_xpath) #>         sep_value <- get_r_string(empty_sep_expr, xpath = \"./SYMBOL_SUB[text() = 'sep']/following-sibling::expr[1]\") #>         lints <- c(lints, xml_nodes_to_lints(empty_sep_expr[!nzchar(sep_value)],  #>             source_expression = source_expression, lint_message = \"paste0(...) is better than paste(..., sep = \\\"\\\").\",  #>             type = \"warning\")) #>     } #>     if (!allow_to_string) { #>         to_string_expr <- xml2::xml_find_all(xml, to_string_xpath) #>         collapse_value <- get_r_string(to_string_expr, xpath = \"./SYMBOL_SUB[text() = 'collapse']/following-sibling::expr[1]\") #>         lints <- c(lints, xml_nodes_to_lints(to_string_expr[collapse_value ==  #>             \", \"], source_expression = source_expression, lint_message = paste(\"toString(.) is more expressive than paste(., collapse = \\\", \\\").\",  #>             \"Note also glue::glue_collapse() and and::and()\",  #>             \"for constructing human-readable / translation-friendly lists\"),  #>             type = \"warning\")) #>     } #>     paste0_sep_expr <- xml2::xml_find_all(xml, paste0_sep_xpath) #>     lints <- c(lints, xml_nodes_to_lints(paste0_sep_expr, source_expression = source_expression,  #>         lint_message = \"sep= is not a formal argument to paste0(); did you mean to use paste(), or collapse=?\",  #>         type = \"warning\")) #>     lints #> } #> <bytecode: 0x561ee90094a0> #> <environment: 0x561eeae11e68> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"paste_linter\" #>  #> $pipe_call_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"Use explicit calls in magrittr pipes, i.e., `a %>% foo` should be `a %>% foo()`.\",  #>         type = \"warning\") #> } #> <bytecode: 0x561ee90020b8> #> <environment: 0x561eeae7cc50> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"pipe_call_linter\" #>  #> $pipe_continuation_linter #> function (source_expression)  #> { #>     x <- global_xml_parsed_content(source_expression) #>     if (is.null(x)) { #>         return() #>     } #>     pipe_exprs <- xml_find_all(x, multiline_pipe_test) #>     xml_nodes_to_lints(pipe_exprs, source_expression = source_expression,  #>         lint_message = paste(\"`%>%` should always have a space before it and a new line after it,\",  #>             \"unless the full pipeline fits on one line.\"), type = \"style\") #> } #> <bytecode: 0x561eeba855d8> #> <environment: 0x561eeaee0378> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"pipe_continuation_linter\" #>  #> $redundant_ifelse_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     lints <- list() #>     tf_expr <- xml2::xml_find_all(xml, tf_xpath) #>     matched_call <- xp_call_name(tf_expr) #>     first_arg <- xml2::xml_find_chr(tf_expr, \"string(expr[3]/NUM_CONST)\") #>     second_arg <- xml2::xml_find_chr(tf_expr, \"string(expr[4]/NUM_CONST)\") #>     tf_message <- sprintf(\"Just use the logical condition (or its negation) directly instead of calling %s(x, %s, %s)\",  #>         matched_call, first_arg, second_arg) #>     lints <- c(lints, xml_nodes_to_lints(tf_expr, source_expression,  #>         tf_message, type = \"warning\")) #>     if (!allow10) { #>         num_expr <- xml2::xml_find_all(xml, num_xpath) #>         matched_call <- xp_call_name(num_expr) #>         first_arg <- xml2::xml_find_chr(num_expr, \"string(expr[3]/NUM_CONST)\") #>         second_arg <- xml2::xml_find_chr(num_expr, \"string(expr[4]/NUM_CONST)\") #>         replacement <- ifelse(first_arg %in% c(\"0\", \"1\") | second_arg %in%  #>             c(\"0\", \"1\"), \"as.numeric\", \"as.integer\") #>         lint_message <- paste(sprintf(\"Prefer %s(x) to %s(x, %s, %s) if really needed,\",  #>             replacement, matched_call, first_arg, second_arg),  #>             \"but do note that R will usually convert logical vectors to 0/1 on the fly when needed.\") #>         lints <- c(lints, xml_nodes_to_lints(num_expr, source_expression,  #>             lint_message, type = \"warning\")) #>     } #>     return(lints) #> } #> <bytecode: 0x561ee8fe0c08> #> <environment: 0x561eeaf44a50> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"redundant_ifelse_linter\" #>  #> $regex_subset_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     grep_expr <- xml2::xml_find_all(xml, grep_xpath) #>     grep_lints <- xml_nodes_to_lints(grep_expr, source_expression = source_expression,  #>         lint_message = \"Prefer grep(pattern, x, ..., value = TRUE) over x[grep(pattern, x, ...)] and x[grepl(pattern, x, ...)].\",  #>         type = \"warning\") #>     stringr_expr <- xml2::xml_find_all(xml, stringr_xpath) #>     stringr_lints <- xml_nodes_to_lints(stringr_expr, source_expression = source_expression,  #>         lint_message = \"Prefer stringr::str_subset(x, pattern) over x[str_detect(x, pattern)] and x[str_which(x, pattern)].\",  #>         type = \"warning\") #>     return(c(grep_lints, stringr_lints)) #> } #> <bytecode: 0x561ee8fd79a8> #> <environment: 0x561eeafc83a8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"regex_subset_linter\" #>  #> $semicolon_linter #> function (source_expression)  #> { #>     tokens <- with_id(source_expression, ids_with_token(source_expression,  #>         \"';'\")) #>     is_trailing <- is_trailing_sc(tokens, source_expression) #>     to_keep <- (is_trailing & !allow_trailing) | (!is_trailing &  #>         !allow_compound) #>     tokens <- tokens[to_keep, ] #>     are_trailing <- is_trailing[to_keep] #>     Map(function(token, is_trailing) { #>         msg <- if (is_trailing) { #>             \"Trailing semicolons are not needed.\" #>         } #>         else { #>             \"Compound semicolons are discouraged. Replace them by a newline.\" #>         } #>         Lint(filename = source_expression[[\"filename\"]], line_number = token[[\"line1\"]],  #>             column_number = token[[\"col1\"]], type = \"style\",  #>             message = msg, line = source_expression[[\"lines\"]][[as.character(token[[\"line1\"]])]],  #>             ranges = list(c(token[[\"col1\"]], token[[\"col2\"]]))) #>     }, split(tokens, seq_len(nrow(tokens))), are_trailing) #> } #> <bytecode: 0x561eeba8c368> #> <environment: 0x561eeb02ccf8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"semicolon_linter\" #>  #> $seq_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     badx <- xml2::xml_find_all(xml, xpath) #>     get_fun <- function(x, n) { #>         funcall <- xml2::xml_children(xml2::xml_children(x)[[n]]) #>         fun <- gsub(\"\\\\(.*\\\\)\", \"(...)\", trimws(xml2::xml_text(funcall[[1L]]))) #>         if (fun %in% bad_funcs)  #>             paste0(fun, \"(...)\") #>         else fun #>     } #>     xml_nodes_to_lints(badx, source_expression = source_expression,  #>         lint_message = function(expr) { #>             dot_expr1 <- get_fun(expr, 1L) #>             dot_expr2 <- get_fun(expr, 3L) #>             if (any(grepl(\"length(\", c(dot_expr1, dot_expr2),  #>                 fixed = TRUE))) { #>                 replacement <- \"seq_along\" #>             } #>             else { #>                 replacement <- \"seq_len\" #>             } #>             sprintf(\"%s:%s is likely to be wrong in the empty edge case. Use %s() instead.\",  #>                 dot_expr1, dot_expr2, replacement) #>         }, type = \"warning\") #> } #> <bytecode: 0x561eeba92250> #> <environment: 0x561eeb093fc0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"seq_linter\" #>  #> $single_quotes_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     content <- source_expression$full_parsed_content #>     str_idx <- which(content$token == \"STR_CONST\") #>     squote_matches <- which(re_matches(content[str_idx, \"text\"],  #>         squote_regex)) #>     lapply(squote_matches, function(id) { #>         with(content[str_idx[id], ], { #>             line <- source_expression$file_lines[[line1]] #>             col2 <- if (line1 == line2)  #>                 col2 #>             else nchar(line) #>             Lint(filename = source_expression$filename, line_number = line1,  #>                 column_number = col1, type = \"style\", message = \"Only use double-quotes.\",  #>                 line = line, ranges = list(c(col1, col2))) #>         }) #>     }) #> } #> <bytecode: 0x561eeba99808> #> <environment: 0x561eeb107668> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"single_quotes_linter\" #>  #> $spaces_inside_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     left_expr <- xml2::xml_find_all(xml, left_xpath) #>     left_msg <- ifelse(xml2::xml_text(left_expr) == \"[\", \"Do not place spaces after square brackets.\",  #>         \"Do not place spaces after parentheses.\") #>     right_expr <- xml2::xml_find_all(xml, right_xpath) #>     right_msg <- ifelse(xml2::xml_find_chr(right_expr, \"string(./following-sibling::*[1])\") ==  #>         \"]\", \"Do not place spaces before square brackets.\", \"Do not place spaces before parentheses.\") #>     xml_nodes_to_lints(c(left_expr, right_expr), source_expression = source_expression,  #>         lint_message = c(left_msg, right_msg), range_start_xpath = \"number(./@col2 + 1)\",  #>         range_end_xpath = \"number(./following-sibling::*[1]/@col1 - 1)\") #> } #> <bytecode: 0x561eebaa2598> #> <environment: 0x561eeb1a13b8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"spaces_inside_linter\" #>  #> $spaces_left_parentheses_linter #> function (source_expression)  #> { #>     if (is_lint_level(source_expression, \"file\")) { #>         xml <- source_expression$full_xml_parsed_content #>         xpath <- file_level_xpath #>     } #>     else { #>         xml <- source_expression$xml_parsed_content #>         xpath <- expression_level_xpath #>     } #>     bad_paren <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_paren, source_expression, lint_message = \"Place a space before left parenthesis, except in a function call.\",  #>         type = \"style\") #> } #> <bytecode: 0x561eebaa60c8> #> <environment: 0x561eeb255890> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"spaces_left_parentheses_linter\" #>  #> $sprintf_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     sprintf_calls <- xml2::xml_find_all(xml, xpath) #>     message <- vapply(sprintf_calls, capture_sprintf_warning,  #>         character(1L)) #>     has_message <- !is.na(message) #>     xml_nodes_to_lints(sprintf_calls[has_message], source_expression = source_expression,  #>         lint_message = message[has_message], type = \"warning\") #> } #> <bytecode: 0x561ee8fd6a48> #> <environment: 0x561eeb2ccaa8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"sprintf_linter\" #>  #> $strings_as_factors_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = paste(\"This code relies on the default value of stringsAsFactors,\",  #>             \"which changed in version R 4.0. Please supply an explicit value for\",  #>             \"stringsAsFactors for this code to work with versions of R both before\",  #>             \"and after this switch.\"), type = \"warning\") #> } #> <bytecode: 0x561ee8fd0a48> #> <environment: 0x561eeb359588> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"strings_as_factors_linter\" #>  #> $system_file_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     outer_call <- xp_call_name(bad_expr) #>     lint_message <- paste(\"Use the `...` argument of system.file() to expand paths,\",  #>         \"e.g. system.file(\\\"data\\\", \\\"model.csv\\\", package = \\\"myrf\\\") instead of\",  #>         ifelse(outer_call == \"system.file\", \"system.file(file.path(\\\"data\\\", \\\"model.csv\\\"), package = \\\"myrf\\\")\",  #>             \"file.path(system.file(package = \\\"myrf\\\"), \\\"data\\\", \\\"model.csv\\\")\")) #>     xml_nodes_to_lints(bad_expr, source_expression, lint_message,  #>         type = \"warning\") #> } #> <bytecode: 0x561ee8fcf0a0> #> <environment: 0x561eeb3e51a0> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"system_file_linter\" #>  #> $T_and_F_symbol_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     bad_exprs <- xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xpath) #>     bad_assigns <- xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xpath_assignment) #>     make_lints <- function(expr, fmt) { #>         symbol <- xml2::xml_text(expr) #>         lint_message <- sprintf(fmt, replacement_map[symbol],  #>             symbol) #>         xml_nodes_to_lints(xml = expr, source_expression = source_expression,  #>             lint_message = lint_message, type = \"style\", column_number_xpath = \"number(./@col2 + 1)\",  #>             range_end_xpath = \"number(./@col2 + 1)\") #>     } #>     c(make_lints(bad_exprs, \"Use %s instead of the symbol %s.\"),  #>         make_lints(bad_assigns, \"Don't use %2$s as a variable name, as it can break code relying on %2$s being %1$s.\")) #> } #> <bytecode: 0x561eebaa6ea0> #> <environment: 0x561eeb446618> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"T_and_F_symbol_linter\" #>  #> $todo_comment_linter #> function (source_expression)  #> { #>     tokens <- with_id(source_expression, ids_with_token(source_expression,  #>         \"COMMENT\")) #>     are_todo <- re_matches(tokens[[\"text\"]], todo_comment_regex,  #>         ignore.case = TRUE) #>     tokens <- tokens[are_todo, ] #>     lapply(split(tokens, seq_len(nrow(tokens))), function(token) { #>         Lint(filename = source_expression[[\"filename\"]], line_number = token[[\"line1\"]],  #>             column_number = token[[\"col1\"]], type = \"style\",  #>             message = \"TODO comments should be removed.\", line = source_expression[[\"lines\"]][[as.character(token[[\"line1\"]])]],  #>             ranges = list(c(token[[\"col1\"]], token[[\"col2\"]]))) #>     }) #> } #> <bytecode: 0x561ee8fc88f8> #> <environment: 0x561eeb4a8a60> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"todo_comment_linter\" #>  #> $trailing_blank_lines_linter #> function (source_expression)  #> { #>     blanks <- re_matches(source_expression$file_lines, rex(start,  #>         any_spaces, end)) #>     line_number <- length(source_expression$file_lines) #>     lints <- list() #>     while (line_number > 0L && (is.na(blanks[[line_number]]) ||  #>         isTRUE(blanks[[line_number]]))) { #>         if (!is.na(blanks[[line_number]])) { #>             lints[[length(lints) + 1L]] <- Lint(filename = source_expression$filename,  #>                 line_number = line_number, column_number = 1L,  #>                 type = \"style\", message = \"Trailing blank lines are superfluous.\",  #>                 line = source_expression$file_lines[[line_number]]) #>         } #>         line_number <- line_number - 1L #>     } #>     if (identical(source_expression$terminal_newline, FALSE)) { #>         last_line <- tail(source_expression$file_lines, 1L) #>         lints[[length(lints) + 1L]] <- Lint(filename = source_expression$filename,  #>             line_number = length(source_expression$file_lines),  #>             column_number = nchar(last_line) + 1L, type = \"style\",  #>             message = \"Missing terminal newline.\", line = last_line) #>     } #>     lints #> } #> <bytecode: 0x561ee8f3cb78> #> <environment: 0x561eeb535350> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"trailing_blank_lines_linter\" #>  #> $trailing_whitespace_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     res <- re_matches(source_expression$file_lines, rex(blanks,  #>         end), locations = TRUE) #>     if (isTRUE(allow_empty_lines)) { #>         bad_lines <- which(res$start > 1L) #>     } #>     else { #>         bad_lines <- which(!is.na(res$start)) #>     } #>     if (isTRUE(allow_in_strings) && !is.null(source_expression$full_xml_parsed_content)) { #>         all_str_consts <- xml2::xml_find_all(source_expression$full_xml_parsed_content,  #>             \"//STR_CONST\") #>         start_lines <- as.integer(xml2::xml_attr(all_str_consts,  #>             \"line1\")) #>         end_lines <- as.integer(xml2::xml_attr(all_str_consts,  #>             \"line2\")) #>         is_in_str <- vapply(bad_lines, function(ln) { #>             any(start_lines <= ln & ln < end_lines) #>         }, logical(1L)) #>         bad_lines <- bad_lines[!is_in_str] #>     } #>     lapply(bad_lines, function(line) { #>         Lint(filename = source_expression$filename, line_number = line,  #>             column_number = res$start[[line]], type = \"style\",  #>             message = \"Trailing whitespace is superfluous.\",  #>             line = source_expression$file_lines[[line]], ranges = list(c(res$start[[line]],  #>                 res$end[[line]]))) #>     }) #> } #> <bytecode: 0x561eebaaf290> #> <environment: 0x561eeb5a1370> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"trailing_whitespace_linter\" #>  #> $undesirable_function_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     matched_nodes <- xml2::xml_find_all(source_expression$xml_parsed_content,  #>         xpath) #>     lapply(matched_nodes, function(node) { #>         fun_name <- xml2::xml_text(node) #>         msg <- sprintf(\"Function \\\"%s\\\" is undesirable.\", fun_name) #>         alternative <- fun[[fun_name]] #>         if (!is.na(alternative)) { #>             msg <- paste(msg, sprintf(\"As an alternative, %s.\",  #>                 alternative)) #>         } #>         line <- xml2::xml_attr(node, \"line1\") #>         col1 <- as.integer(xml2::xml_attr(node, \"col1\")) #>         col2 <- as.integer(xml2::xml_attr(node, \"col2\")) #>         Lint(filename = source_expression$filename, line_number = as.integer(line),  #>             column_number = col1, type = \"style\", message = msg,  #>             line = source_expression$lines[[line]], ranges = list(c(col1,  #>                 col2))) #>     }) #> } #> <bytecode: 0x561ee8fc2e00> #> <environment: 0x561eeb6260a8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"undesirable_function_linter\" #>  #> $undesirable_operator_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_op <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_op, source_expression = source_expression,  #>         lint_message = function(expr) { #>             op_name <- xml2::xml_text(expr) #>             msg <- sprintf(\"Operator `%s` is undesirable.\", op_name) #>             alt_op <- op[[op_name]] #>             if (!is.na(alt_op)) { #>                 msg <- paste(msg, alt_op) #>             } #>             msg #>         }, type = \"warning\") #> } #> <bytecode: 0x561ee8fb2d90> #> <environment: 0x561eeb6daa40> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"undesirable_operator_linter\" #>  #> $unneeded_concatenation_linter #> function (source_expression)  #> { #>     tokens <- source_expression[[\"parsed_content\"]] <- filter_out_token_type(source_expression[[\"parsed_content\"]],  #>         \"expr\") #>     lapply(ids_with_token(source_expression, \"SYMBOL_FUNCTION_CALL\"),  #>         function(token_num) { #>             num_args <- get_num_concat_args(token_num, tokens) #>             if (num_args == 0L || num_args == 1L) { #>                 token <- with_id(source_expression, token_num) #>                 start_col_num <- token[[\"col1\"]] #>                 end_col_num <- token[[\"col2\"]] #>                 line_num <- token[[\"line1\"]] #>                 line <- source_expression[[\"lines\"]][[as.character(line_num)]] #>                 Lint(filename = source_expression[[\"filename\"]],  #>                   line_number = line_num, column_number = start_col_num,  #>                   type = \"warning\", message = if (num_args)  #>                     msg_const #>                   else msg_empty, line = line, ranges = list(c(start_col_num,  #>                     end_col_num))) #>             } #>         }) #> } #> <bytecode: 0x561ee8f84808> #> <environment: 0x561eeb7af020> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"unneeded_concatenation_linter\" #>  #> $unreachable_code_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"Code and comments coming after a top-level return() or stop() should be removed.\",  #>         type = \"warning\") #> } #> <bytecode: 0x561ee8f7f138> #> <environment: 0x561eeb817a88> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"unreachable_code_linter\" #>  #> $unused_import_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"file\")) { #>         return(list()) #>     } #>     xml <- source_expression$full_xml_parsed_content #>     import_exprs <- xml2::xml_find_all(xml, import_xpath) #>     if (length(import_exprs) == 0L) { #>         return(list()) #>     } #>     imported_pkgs <- xml2::xml_find_chr(import_exprs, \"string(expr[STR_CONST|SYMBOL])\") #>     imported_pkgs <- as.character(parse(text = imported_pkgs,  #>         keep.source = FALSE)) #>     used_symbols <- xml2::xml_text(xml2::xml_find_all(xml, xp_used_symbols)) #>     is_used <- vapply(imported_pkgs, function(pkg) { #>         if (pkg %in% except_packages || !requireNamespace(pkg,  #>             quietly = TRUE)) { #>             return(TRUE) #>         } #>         package_exports <- getNamespaceExports(pkg) #>         any(package_exports %in% used_symbols) #>     }, logical(1L)) #>     is_ns_used <- vapply(imported_pkgs, function(pkg) { #>         ns_usage <- xml2::xml_find_first(xml, paste0(\"//SYMBOL_PACKAGE[text() = '\",  #>             pkg, \"']\")) #>         !identical(ns_usage, xml2::xml_missing()) #>     }, logical(1L)) #>     is_unused <- !is_used #>     if (allow_ns_usage) { #>         is_unused[is_ns_used] <- FALSE #>     } #>     xml_nodes_to_lints(import_exprs[is_unused], source_expression = source_expression,  #>         lint_message = function(import_expr) { #>             pkg <- get_r_string(import_expr, xpath = \"expr[STR_CONST|SYMBOL]\") #>             if (is_ns_used[match(pkg, imported_pkgs)]) { #>                 paste0(\"package '\", pkg, \"' is only used by namespace. \",  #>                   \"Check that it is installed using loadNamespace() instead.\") #>             } #>             else { #>                 paste0(\"package '\", pkg, \"' is attached but never used.\") #>             } #>         }, type = \"warning\") #> } #> <bytecode: 0x561ee8f75330> #> <environment: 0x561eeb87ade8> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"unused_import_linter\" #>  #> $vector_logic_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = \"Conditional expressions require scalar logical operators (&& and ||)\",  #>         type = \"warning\") #> } #> <bytecode: 0x561eebab5840> #> <environment: 0x561eeb8f2c90> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"vector_logic_linter\" #>  #> $yoda_test_linter #> function (source_expression)  #> { #>     if (!is_lint_level(source_expression, \"expression\")) { #>         return(list()) #>     } #>     xml <- source_expression$xml_parsed_content #>     bad_expr <- xml2::xml_find_all(xml, xpath) #>     xml_nodes_to_lints(bad_expr, source_expression = source_expression,  #>         lint_message = function(expr) { #>             matched_call <- xp_call_name(expr) #>             second_const <- xml2::xml_find_first(expr, glue::glue(\"expr[position() = 3 and ({const_condition})]\")) #>             if (is.na(second_const)) { #>                 paste(\"Tests should compare objects in the order 'actual', 'expected', not the reverse.\",  #>                   sprintf(\"For example, do %1$s(foo(x), 2L) instead of %1$s(2L, foo(x)).\",  #>                     matched_call)) #>             } #>             else { #>                 sprintf(\"Avoid storing placeholder tests like %s(1, 1)\",  #>                   matched_call) #>             } #>         }, type = \"warning\") #> } #> <bytecode: 0x561eec9925e8> #> <environment: 0x561eeb966a68> #> attr(,\"class\") #> [1] \"linter\"         \"lintr_function\" #> attr(,\"name\") #> [1] \"yoda_test_linter\" #>   # Get all linters tagged as \"default\" from lintr and mypkg if (FALSE) linters_with_tags(\"default\", packages = c(\"lintr\", \"mypkg\"))"},{"path":"https://lintr.r-lib.org/reference/lintr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Lintr — lintr-package","title":"Lintr — lintr-package","text":"Checks adherence given style, syntax errors possible semantic issues. Supports fly checking R code edited Emacs, Vim Sublime Text.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/lintr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lintr — lintr-package","text":"Maintainer: Jim Hester james.f.hester@gmail.com Authors: Florent Angly Russ Hyde Michael Chirico Kun Ren Alexander Rosenstock","code":""},{"path":"https://lintr.r-lib.org/reference/literal_coercion_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of correctly-typed literals over literal coercions — literal_coercion_linter","title":"Require usage of correctly-typed literals over literal coercions — literal_coercion_linter","text":".integer(1) 1L latter concise gets typed correctly compilation.","code":""},{"path":"https://lintr.r-lib.org/reference/literal_coercion_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of correctly-typed literals over literal coercions — literal_coercion_linter","text":"","code":"literal_coercion_linter()"},{"path":"https://lintr.r-lib.org/reference/literal_coercion_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Require usage of correctly-typed literals over literal coercions — literal_coercion_linter","text":"applies missing sentinels like NA -- typically, necessary specify storage type NA, , prefer using typed version (e.g. NA_real_) instead coercion (like .numeric(NA)).","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/literal_coercion_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of correctly-typed literals over literal coercions — literal_coercion_linter","text":"best_practices, consistency, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/missing_argument_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing argument linter — missing_argument_linter","title":"Missing argument linter — missing_argument_linter","text":"Check missing arguments function calls.","code":""},{"path":"https://lintr.r-lib.org/reference/missing_argument_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing argument linter — missing_argument_linter","text":"","code":"missing_argument_linter(except = c(\"switch\", \"alist\"))"},{"path":"https://lintr.r-lib.org/reference/missing_argument_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing argument linter — missing_argument_linter","text":"except character vector function names exceptions.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/missing_argument_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Missing argument linter — missing_argument_linter","text":"common_mistakes, configurable, correctness","code":""},{"path":"https://lintr.r-lib.org/reference/missing_package_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing package linter — missing_package_linter","title":"Missing package linter — missing_package_linter","text":"Check missing packages library(), require(), loadNamespace() requireNamespace() calls.","code":""},{"path":"https://lintr.r-lib.org/reference/missing_package_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing package linter — missing_package_linter","text":"","code":"missing_package_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/missing_package_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Missing package linter — missing_package_linter","text":"common_mistakes, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/modify_defaults.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify lintr defaults — modify_defaults","title":"Modify lintr defaults — modify_defaults","text":"Modify list defaults name, allowing replacement, deletion addition new elements.","code":""},{"path":"https://lintr.r-lib.org/reference/modify_defaults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify lintr defaults — modify_defaults","text":"","code":"modify_defaults(defaults, ...)"},{"path":"https://lintr.r-lib.org/reference/modify_defaults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify lintr defaults — modify_defaults","text":"defaults named list elements modify. ... arguments elements change. unnamed, argument automatically named. named argument already exists defaults, replaced new element. exist, added. value NULL, element removed.","code":""},{"path":"https://lintr.r-lib.org/reference/modify_defaults.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify lintr defaults — modify_defaults","text":"modified list elements, sorted name. achieve sort platform-independent way, two transformations applied names: (1) replace _ 0 (2) convert tolower().","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/modify_defaults.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify lintr defaults — modify_defaults","text":"","code":"# custom list of undesirable functions: #    remove sapply (using NULL) #    add cat (with a accompanying message), #    add print (unnamed, i.e. with no accompanying message) #    add return (as taken from all_undesirable_functions) my_undesirable_functions <- modify_defaults(defaults = default_undesirable_functions,   sapply=NULL, \"cat\"=\"No cat allowed\", \"print\", all_undesirable_functions[[\"return\"]]) #> Warning: Trying to remove ‘return’, which is not in `defaults`."},{"path":"https://lintr.r-lib.org/reference/namespace_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Namespace linter — namespace_linter","title":"Namespace linter — namespace_linter","text":"Check missing packages symbols namespace calls. Note using check_exports=TRUE check_nonexports=TRUE load packages used user code potentially change global state.","code":""},{"path":"https://lintr.r-lib.org/reference/namespace_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Namespace linter — namespace_linter","text":"","code":"namespace_linter(check_exports = TRUE, check_nonexports = TRUE)"},{"path":"https://lintr.r-lib.org/reference/namespace_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Namespace linter — namespace_linter","text":"check_exports Check symbol exported namespace namespace::symbol calls. check_nonexports Check symbol exists namespace namespace:::symbol calls.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/namespace_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Namespace linter — namespace_linter","text":"configurable, correctness, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/nested_ifelse_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block usage of nested ifelse() calls — nested_ifelse_linter","title":"Block usage of nested ifelse() calls — nested_ifelse_linter","text":"Calling ifelse nested calls problematic two main reasons: can hard read -- mapping code expected output code can messy task/require lot mental bandwidth, especially code nests inefficient -- ifelse can evaluate arguments yes (see https://stackoverflow.com/q/16275149); issue exacerbated nested calls","code":""},{"path":"https://lintr.r-lib.org/reference/nested_ifelse_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block usage of nested ifelse() calls — nested_ifelse_linter","text":"","code":"nested_ifelse_linter()"},{"path":"https://lintr.r-lib.org/reference/nested_ifelse_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Block usage of nested ifelse() calls — nested_ifelse_linter","text":"Users can instead rely readable alternative modeled SQL CASE statements, data.table::fcase dplyr::case_when, use look---merge approach (build mapping table values outputs merge input).","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/nested_ifelse_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block usage of nested ifelse() calls — nested_ifelse_linter","text":"efficiency, readability","code":""},{"path":"https://lintr.r-lib.org/reference/no_tab_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"No tab linter — no_tab_linter","title":"No tab linter — no_tab_linter","text":"Check spaces used indentation, tabs.","code":""},{"path":"https://lintr.r-lib.org/reference/no_tab_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"No tab linter — no_tab_linter","text":"","code":"no_tab_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/no_tab_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"No tab linter — no_tab_linter","text":"consistency, default, style","code":""},{"path":"https://lintr.r-lib.org/reference/nonportable_path_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-portable path linter — nonportable_path_linter","title":"Non-portable path linter — nonportable_path_linter","text":"Check file.path() used construct safe portable paths.","code":""},{"path":"https://lintr.r-lib.org/reference/nonportable_path_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-portable path linter — nonportable_path_linter","text":"","code":"nonportable_path_linter(lax = TRUE)"},{"path":"https://lintr.r-lib.org/reference/nonportable_path_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-portable path linter — nonportable_path_linter","text":"lax Less stringent linting, leading fewer false positives. TRUE, lint path strings, contain least two path elements, one least two characters contain alphanumeric chars (including UTF-8), spaces, win32-allowed punctuation","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/nonportable_path_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Non-portable path linter — nonportable_path_linter","text":"best_practices, configurable, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/normalize_exclusions.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize lint exclusions — normalize_exclusions","title":"Normalize lint exclusions — normalize_exclusions","text":"Normalize lint exclusions","code":""},{"path":"https://lintr.r-lib.org/reference/normalize_exclusions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize lint exclusions — normalize_exclusions","text":"","code":"normalize_exclusions(x, normalize_path = TRUE, root = getwd(), pattern = NULL)"},{"path":"https://lintr.r-lib.org/reference/normalize_exclusions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize lint exclusions — normalize_exclusions","text":"x Exclusion specification character vector filenames directories relative root named list integers specifying lines excluded per file named list named lists specifying linters lines excluded linters per file. normalize_path names returned exclusion list normalized paths? , relative root. root Base directory relative filename resolution. pattern non-NULL, exclude files excluded directories match pattern. Passed list.files directory excluded.","code":""},{"path":"https://lintr.r-lib.org/reference/normalize_exclusions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize lint exclusions — normalize_exclusions","text":"named list file exclusions. names list specify filenames excluded. file exclusion possibly named list containing line numbers exclude, sentinel Inf completely excluded files. entry named, exclusions take effect linter name. normalize_path TRUE, file names normalized relative root. Otherwise paths left provided (relative root absolute).","code":""},{"path":"https://lintr.r-lib.org/reference/numeric_leading_zero_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of a leading zero in all fractional numerics — numeric_leading_zero_linter","title":"Require usage of a leading zero in all fractional numerics — numeric_leading_zero_linter","text":".1 0.1 mean thing, latter easier read due small size '.' glyph.","code":""},{"path":"https://lintr.r-lib.org/reference/numeric_leading_zero_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of a leading zero in all fractional numerics — numeric_leading_zero_linter","text":"","code":"numeric_leading_zero_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/numeric_leading_zero_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of a leading zero in all fractional numerics — numeric_leading_zero_linter","text":"consistency, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/object_length_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Object length linter — object_length_linter","title":"Object length linter — object_length_linter","text":"Check object names long. length object name defined length characters, removing extraneous parts:","code":""},{"path":"https://lintr.r-lib.org/reference/object_length_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object length linter — object_length_linter","text":"","code":"object_length_linter(length = 30L)"},{"path":"https://lintr.r-lib.org/reference/object_length_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object length linter — object_length_linter","text":"length maximum variable name length allowed.","code":""},{"path":"https://lintr.r-lib.org/reference/object_length_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Object length linter — object_length_linter","text":"generic prefixes implementations S3 generics, e.g. .data.frame.my_class length 8. leading ., e.g. .my_hidden_function length 18. \"%%\" infix operators, e.g. %my_op% length 5. trailing <- assignment functions, e.g. my_attr<- length 7.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/object_length_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Object length linter — object_length_linter","text":"configurable, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/object_name_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Object name linter — object_name_linter","title":"Object name linter — object_name_linter","text":"Check object names conform naming style. default naming styles \"snake_case\" \"symbols\".","code":""},{"path":"https://lintr.r-lib.org/reference/object_name_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object name linter — object_name_linter","text":"","code":"object_name_linter(styles = c(\"snake_case\", \"symbols\"))"},{"path":"https://lintr.r-lib.org/reference/object_name_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object name linter — object_name_linter","text":"styles subset ‘symbols’, ‘CamelCase’, ‘camelCase’, ‘snake_case’, ‘SNAKE_CASE’, ‘dotted.case’, ‘lowercase’, ‘UPPERCASE’ . name match least one styles.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/object_name_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Object name linter — object_name_linter","text":"configurable, consistency, default, style","code":""},{"path":"https://lintr.r-lib.org/reference/object_usage_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Object usage linter — object_usage_linter","title":"Object usage linter — object_usage_linter","text":"Check closures proper usage using codetools::checkUsage(). Note runs base::eval() code, use untrusted code.","code":""},{"path":"https://lintr.r-lib.org/reference/object_usage_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object usage linter — object_usage_linter","text":"","code":"object_usage_linter(interpret_glue = TRUE)"},{"path":"https://lintr.r-lib.org/reference/object_usage_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object usage linter — object_usage_linter","text":"interpret_glue TRUE, interpret glue::glue() calls avoid false positives caused local variables used glue expression.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/object_usage_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Object usage linter — object_usage_linter","text":"correctness, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/open_curly_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Open curly linter — open_curly_linter","title":"Open curly linter — open_curly_linter","text":"Check opening curly braces never line always followed newline.","code":""},{"path":"https://lintr.r-lib.org/reference/open_curly_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open curly linter — open_curly_linter","text":"","code":"open_curly_linter(allow_single_line = FALSE)"},{"path":"https://lintr.r-lib.org/reference/open_curly_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Open curly linter — open_curly_linter","text":"allow_single_line TRUE, allow open closed curly pair line.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/open_curly_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Open curly linter — open_curly_linter","text":"configurable, deprecated, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/outer_negation_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of !any(.) over all(!.), !all(.) over any(!.) — outer_negation_linter","title":"Require usage of !any(.) over all(!.), !all(.) over any(!.) — outer_negation_linter","text":"(!x) logically equivalent !(x); ditto equivalence (!x) !(x). Negating aggregation requires inverting one logical value, typically readable.","code":""},{"path":"https://lintr.r-lib.org/reference/outer_negation_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of !any(.) over all(!.), !all(.) over any(!.) — outer_negation_linter","text":"","code":"outer_negation_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/outer_negation_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of !any(.) over all(!.), !all(.) over any(!.) — outer_negation_linter","text":"best_practices, efficiency, readability","code":""},{"path":"https://lintr.r-lib.org/reference/package_development_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Package development linters — package_development_linters","title":"Package development linters — package_development_linters","text":"Linters useful package developers, example writing consistent tests.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/package_development_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Package development linters — package_development_linters","text":"following linters tagged 'package_development': backport_linter conjunct_test_linter expect_comparison_linter expect_identical_linter expect_length_linter expect_named_linter expect_not_linter expect_null_linter expect_s3_class_linter expect_s4_class_linter expect_true_false_linter expect_type_linter package_hooks_linter yoda_test_linter","code":""},{"path":"https://lintr.r-lib.org/reference/package_hooks_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Package hooks linter — package_hooks_linter","title":"Package hooks linter — package_hooks_linter","text":"Check various common \"gotchas\" .onLoad(), .onAttach(), .Last.lib(), .onDetach() namespace hooks cause R CMD check issues. See Writing R Extensions details.","code":""},{"path":"https://lintr.r-lib.org/reference/package_hooks_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package hooks linter — package_hooks_linter","text":"","code":"package_hooks_linter()"},{"path":"https://lintr.r-lib.org/reference/package_hooks_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package hooks linter — package_hooks_linter","text":".onLoad() call cat(), message(), print(), writeLines(), packageStartupMessage(), require(), library(), installed.packages(). .onAttach() call cat(), message(), print(), writeLines(), library.dynam(), require(), library(), installed.packages(). .Last.lib() .onDetach() call library.dynam.unload(). .onLoad() .onAttach() take two arguments, names matching ^lib ^pkg; .Last.lib() .onDetach() take one argument name matching ^lib.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/package_hooks_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Package hooks linter — package_hooks_linter","text":"correctness, package_development, style","code":""},{"path":"https://lintr.r-lib.org/reference/paren_body_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Parenthesis before body linter — paren_body_linter","title":"Parenthesis before body linter — paren_body_linter","text":"Check space right parenthesis body expression.","code":""},{"path":"https://lintr.r-lib.org/reference/paren_body_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parenthesis before body linter — paren_body_linter","text":"","code":"paren_body_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/paren_body_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Parenthesis before body linter — paren_body_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/paren_brace_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Parentheses before brace linter — paren_brace_linter","title":"Parentheses before brace linter — paren_brace_linter","text":"Check space right parentheses opening curly brace.","code":""},{"path":"https://lintr.r-lib.org/reference/paren_brace_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parentheses before brace linter — paren_brace_linter","text":"","code":"paren_brace_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/paren_brace_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Parentheses before brace linter — paren_brace_linter","text":"deprecated, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/parse_exclusions.html","id":null,"dir":"Reference","previous_headings":"","what":"read a source file and parse all the excluded lines from it — parse_exclusions","title":"read a source file and parse all the excluded lines from it — parse_exclusions","text":"read source file parse excluded lines ","code":""},{"path":"https://lintr.r-lib.org/reference/parse_exclusions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"read a source file and parse all the excluded lines from it — parse_exclusions","text":"","code":"parse_exclusions(   file,   exclude = settings$exclude,   exclude_start = settings$exclude_start,   exclude_end = settings$exclude_end,   exclude_linter = settings$exclude_linter,   exclude_linter_sep = settings$exclude_linter_sep,   lines = NULL,   linter_names = NULL )"},{"path":"https://lintr.r-lib.org/reference/parse_exclusions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"read a source file and parse all the excluded lines from it — parse_exclusions","text":"file R source file exclude regular expression used mark lines exclude exclude_start regular expression used mark start excluded range exclude_end regular expression used mark end excluded range exclude_linter regular expression used capture list --excluded linters immediately following exclude exclude_start marker. exclude_linter_sep regular expression used split linter list indivdual linter names exclusion. lines character vector content lines file linter_names Names active linters","code":""},{"path":"https://lintr.r-lib.org/reference/parse_exclusions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"read a source file and parse all the excluded lines from it — parse_exclusions","text":"possibly named list excluded lines, possibly specific linters.","code":""},{"path":"https://lintr.r-lib.org/reference/paste_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Raise lints for several common poor usages of paste() — paste_linter","title":"Raise lints for several common poor usages of paste() — paste_linter","text":"following issues linted default linter (can turned optionally):","code":""},{"path":"https://lintr.r-lib.org/reference/paste_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raise lints for several common poor usages of paste() — paste_linter","text":"","code":"paste_linter(allow_empty_sep = FALSE, allow_to_string = FALSE)"},{"path":"https://lintr.r-lib.org/reference/paste_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Raise lints for several common poor usages of paste() — paste_linter","text":"allow_empty_sep Logical, default FALSE. TRUE, usage paste() sep = \"\" linted. allow_to_string Logical, default FALSE. TRUE, usage paste() paste0() collapse = \", \" linted.","code":""},{"path":"https://lintr.r-lib.org/reference/paste_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Raise lints for several common poor usages of paste() — paste_linter","text":"Block usage paste() sep = \"\". paste0() faster, concise alternative. Block usage paste() paste0() collapse = \", \". toString() direct wrapper , alternatives like glue::glue_collapse() might give better messages humans. Block usage paste0() supplies sep= -- formal argument paste0, likely mistake.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/paste_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Raise lints for several common poor usages of paste() — paste_linter","text":"best_practices, consistency","code":""},{"path":"https://lintr.r-lib.org/reference/pipe_call_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe call linter — pipe_call_linter","title":"Pipe call linter — pipe_call_linter","text":"Force explicit calls magrittr pipes, e.g., 1:3 %>% sum() instead 1:3 %>% sum.","code":""},{"path":"https://lintr.r-lib.org/reference/pipe_call_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe call linter — pipe_call_linter","text":"","code":"pipe_call_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/pipe_call_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Pipe call linter — pipe_call_linter","text":"readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/pipe_continuation_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe continuation linter — pipe_continuation_linter","title":"Pipe continuation linter — pipe_continuation_linter","text":"Check step pipeline new line, entire pipe fits one line.","code":""},{"path":"https://lintr.r-lib.org/reference/pipe_continuation_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe continuation linter — pipe_continuation_linter","text":"","code":"pipe_continuation_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/pipe_continuation_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Pipe continuation linter — pipe_continuation_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/read_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Read lintr settings — read_settings","title":"Read lintr settings — read_settings","text":"Lintr searches settings given source file following order. options defined linter.setting. linter_file directory linter_file project directory linter_file user home directory default_settings()","code":""},{"path":"https://lintr.r-lib.org/reference/read_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read lintr settings — read_settings","text":"","code":"read_settings(filename)"},{"path":"https://lintr.r-lib.org/reference/read_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read lintr settings — read_settings","text":"filename source file linted","code":""},{"path":"https://lintr.r-lib.org/reference/read_settings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read lintr settings — read_settings","text":"default linter_file name .lintr can changed option lintr.linter_file. file dcf file, see base::read.dcf() details.","code":""},{"path":"https://lintr.r-lib.org/reference/readability_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Readability linters — readability_linters","title":"Readability linters — readability_linters","text":"Linters highlighting readability issues, missing whitespace.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/readability_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Readability linters — readability_linters","text":"following linters tagged 'readability': brace_linter closed_curly_linter commas_linter commented_code_linter conjunct_test_linter consecutive_stopifnot_linter cyclocomp_linter expect_length_linter expect_named_linter expect_not_linter expect_true_false_linter fixed_regex_linter function_left_parentheses_linter infix_spaces_linter inner_combine_linter line_length_linter nested_ifelse_linter numeric_leading_zero_linter object_length_linter object_usage_linter open_curly_linter outer_negation_linter paren_body_linter paren_brace_linter pipe_call_linter pipe_continuation_linter semicolon_linter semicolon_terminator_linter single_quotes_linter spaces_inside_linter spaces_left_parentheses_linter system_file_linter T_and_F_symbol_linter unneeded_concatenation_linter unreachable_code_linter yoda_test_linter","code":""},{"path":"https://lintr.r-lib.org/reference/redundant_ifelse_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Prevent ifelse() from being used to produce TRUE/FALSE or 1/0 — redundant_ifelse_linter","title":"Prevent ifelse() from being used to produce TRUE/FALSE or 1/0 — redundant_ifelse_linter","text":"Expressions like ifelse(x, TRUE, FALSE) ifelse(x, FALSE, TRUE) redundant; just x !x suffice R code logical vectors core data structure. ifelse(x, 1, 0) also .numeric(x), even needed rarely.","code":""},{"path":"https://lintr.r-lib.org/reference/redundant_ifelse_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prevent ifelse() from being used to produce TRUE/FALSE or 1/0 — redundant_ifelse_linter","text":"","code":"redundant_ifelse_linter(allow10 = FALSE)"},{"path":"https://lintr.r-lib.org/reference/redundant_ifelse_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prevent ifelse() from being used to produce TRUE/FALSE or 1/0 — redundant_ifelse_linter","text":"allow10 Logical, default FALSE. TRUE, usage like ifelse(x, 1, 0) allowed, .e., usage like ifelse(x, TRUE, FALSE) linted.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/redundant_ifelse_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Prevent ifelse() from being used to produce TRUE/FALSE or 1/0 — redundant_ifelse_linter","text":"best_practices, consistency, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/regex_subset_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","title":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","text":"Using value = TRUE grep() returns subset input matches pattern, e.g. grep(\"[-m]\", letters, value = TRUE) return first 13 elements (m).","code":""},{"path":"https://lintr.r-lib.org/reference/regex_subset_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","text":"","code":"regex_subset_linter()"},{"path":"https://lintr.r-lib.org/reference/regex_subset_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","text":"letters[grep(\"[-m]\", letters)] letters[grepl(\"[-m]\", letters)] return thing, circuitously verbosely. stringr package also provides even readable alternative, namely str_subset(), preferred versions using str_detect() str_which().","code":""},{"path":"https://lintr.r-lib.org/reference/regex_subset_linter.html","id":"exceptions","dir":"Reference","previous_headings":"","what":"Exceptions","title":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","text":"Note x[grep(pattern, x)] grep(pattern, x, value = TRUE) completely interchangeable x character (commonly, x factor), output latter character vector former remains factor. still may preferable refactor code, may faster match pattern levels(x) use subset instead.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/regex_subset_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Require usage of direct methods for subsetting strings via regex. — regex_subset_linter","text":"best_practices, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/robustness_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Robustness linters — robustness_linters","title":"Robustness linters — robustness_linters","text":"Linters highlighting code robustness issues, possibly wrong edge case behaviour.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/robustness_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Robustness linters — robustness_linters","text":"following linters tagged 'robustness': absolute_path_linter backport_linter class_equals_linter equals_na_linter missing_package_linter namespace_linter nonportable_path_linter seq_linter strings_as_factors_linter T_and_F_symbol_linter undesirable_function_linter undesirable_operator_linter","code":""},{"path":"https://lintr.r-lib.org/reference/semicolon_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Semicolon linter — semicolon_linter","title":"Semicolon linter — semicolon_linter","text":"Check semicolons terminate expressions.","code":""},{"path":"https://lintr.r-lib.org/reference/semicolon_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semicolon linter — semicolon_linter","text":"","code":"semicolon_linter(allow_compound = FALSE, allow_trailing = FALSE)  semicolon_terminator_linter(semicolon = c(\"compound\", \"trailing\"))"},{"path":"https://lintr.r-lib.org/reference/semicolon_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semicolon linter — semicolon_linter","text":"allow_compound Logical, default FALSE. TRUE, \"compound\" semicolons (e.g. x; y, .e., line code) allowed. allow_trailing Logical, default FALSE. TRUE, \"trailing\" semicolons (.e., terminate lines code) allowed. semicolon character vector defining semicolons report: compound Semicolons separate two statements line. trailing Semicolons following last statement line.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/semicolon_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Semicolon linter — semicolon_linter","text":"configurable, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/seq_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequence linter — seq_linter","title":"Sequence linter — seq_linter","text":"Check 1:length(...), 1:nrow(...), 1:ncol(...), 1:NROW(...) 1:NCOL(...) expressions. often cause bugs right-hand side zero. safer use base::seq_len() base::seq_along() instead.","code":""},{"path":"https://lintr.r-lib.org/reference/seq_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequence linter — seq_linter","text":"","code":"seq_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/seq_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Sequence linter — seq_linter","text":"best_practices, consistency, default, efficiency, robustness","code":""},{"path":"https://lintr.r-lib.org/reference/single_quotes_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Single quotes linter — single_quotes_linter","title":"Single quotes linter — single_quotes_linter","text":"Check double quotes used delimit string constants.","code":""},{"path":"https://lintr.r-lib.org/reference/single_quotes_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single quotes linter — single_quotes_linter","text":"","code":"single_quotes_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/single_quotes_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Single quotes linter — single_quotes_linter","text":"consistency, default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/spaces_inside_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Spaces inside linter — spaces_inside_linter","title":"Spaces inside linter — spaces_inside_linter","text":"Check parentheses square brackets spaces directly inside , .e., directly following opening delimiter directly preceding closing delimiter.","code":""},{"path":"https://lintr.r-lib.org/reference/spaces_inside_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spaces inside linter — spaces_inside_linter","text":"","code":"spaces_inside_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/spaces_inside_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Spaces inside linter — spaces_inside_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/spaces_left_parentheses_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Spaces before parentheses linter — spaces_left_parentheses_linter","title":"Spaces before parentheses linter — spaces_left_parentheses_linter","text":"Check left parentheses space unless function call.","code":""},{"path":"https://lintr.r-lib.org/reference/spaces_left_parentheses_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spaces before parentheses linter — spaces_left_parentheses_linter","text":"","code":"spaces_left_parentheses_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/spaces_left_parentheses_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Spaces before parentheses linter — spaces_left_parentheses_linter","text":"default, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/sprintf_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"sprintf linter — sprintf_linter","title":"sprintf linter — sprintf_linter","text":"Check inconsistent number arguments arguments incompatible types (literal arguments) sprintf calls.","code":""},{"path":"https://lintr.r-lib.org/reference/sprintf_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sprintf linter — sprintf_linter","text":"","code":"sprintf_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/sprintf_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"sprintf linter — sprintf_linter","text":"common_mistakes, correctness","code":""},{"path":"https://lintr.r-lib.org/reference/strings_as_factors_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify cases where stringsAsFactors should be supplied explicitly — strings_as_factors_linter","title":"Identify cases where stringsAsFactors should be supplied explicitly — strings_as_factors_linter","text":"Designed code bases written versions R 4.0 seeking upgrade R >= 4.0, one biggest pain points surely flipping default value stringsAsFactors TRUE FALSE.","code":""},{"path":"https://lintr.r-lib.org/reference/strings_as_factors_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify cases where stringsAsFactors should be supplied explicitly — strings_as_factors_linter","text":"","code":"strings_as_factors_linter()"},{"path":"https://lintr.r-lib.org/reference/strings_as_factors_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify cases where stringsAsFactors should be supplied explicitly — strings_as_factors_linter","text":"always possible tell statically whether change break existing code R dynamically typed -- e.g. data.frame(x) x string, code affected, x number, code unaffected. However, data.frame(x = ''), output unambiguously affected. can instead supply stringsAsFactors = TRUE, make code backwards-compatible. See https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/strings_as_factors_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Identify cases where stringsAsFactors should be supplied explicitly — strings_as_factors_linter","text":"robustness","code":""},{"path":"https://lintr.r-lib.org/reference/style_linters.html","id":null,"dir":"Reference","previous_headings":"","what":"Style linters — style_linters","title":"Style linters — style_linters","text":"Linters highlighting code style issues.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/style_linters.html","id":"linters","dir":"Reference","previous_headings":"","what":"Linters","title":"Style linters — style_linters","text":"following linters tagged 'style': assignment_linter brace_linter closed_curly_linter commas_linter commented_code_linter consecutive_stopifnot_linter cyclocomp_linter extraction_operator_linter function_left_parentheses_linter implicit_integer_linter infix_spaces_linter line_length_linter no_tab_linter numeric_leading_zero_linter object_length_linter object_name_linter object_usage_linter open_curly_linter package_hooks_linter paren_body_linter paren_brace_linter pipe_call_linter pipe_continuation_linter semicolon_linter semicolon_terminator_linter single_quotes_linter spaces_inside_linter spaces_left_parentheses_linter T_and_F_symbol_linter todo_comment_linter trailing_blank_lines_linter trailing_whitespace_linter undesirable_function_linter undesirable_operator_linter unneeded_concatenation_linter","code":""},{"path":"https://lintr.r-lib.org/reference/system_file_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block usage of file.path() with system.file() — system_file_linter","title":"Block usage of file.path() with system.file() — system_file_linter","text":"system.file() ... argument , internally, passed file.path(), including user code repetitive.","code":""},{"path":"https://lintr.r-lib.org/reference/system_file_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block usage of file.path() with system.file() — system_file_linter","text":"","code":"system_file_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/system_file_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block usage of file.path() with system.file() — system_file_linter","text":"best_practices, consistency, readability","code":""},{"path":"https://lintr.r-lib.org/reference/todo_comment_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"TODO comment linter — todo_comment_linter","title":"TODO comment linter — todo_comment_linter","text":"Check source contains TODO comments (case-insensitive).","code":""},{"path":"https://lintr.r-lib.org/reference/todo_comment_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TODO comment linter — todo_comment_linter","text":"","code":"todo_comment_linter(todo = c(\"todo\", \"fixme\"))"},{"path":"https://lintr.r-lib.org/reference/todo_comment_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TODO comment linter — todo_comment_linter","text":"todo Vector strings identify TODO comments.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/todo_comment_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"TODO comment linter — todo_comment_linter","text":"configurable, style","code":""},{"path":"https://lintr.r-lib.org/reference/trailing_blank_lines_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Trailing blank lines linter — trailing_blank_lines_linter","title":"Trailing blank lines linter — trailing_blank_lines_linter","text":"Check trailing blank lines source code.","code":""},{"path":"https://lintr.r-lib.org/reference/trailing_blank_lines_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trailing blank lines linter — trailing_blank_lines_linter","text":"","code":"trailing_blank_lines_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/trailing_blank_lines_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Trailing blank lines linter — trailing_blank_lines_linter","text":"default, style","code":""},{"path":"https://lintr.r-lib.org/reference/trailing_whitespace_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Trailing whitespace linter — trailing_whitespace_linter","title":"Trailing whitespace linter — trailing_whitespace_linter","text":"Check space characters end source lines.","code":""},{"path":"https://lintr.r-lib.org/reference/trailing_whitespace_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trailing whitespace linter — trailing_whitespace_linter","text":"","code":"trailing_whitespace_linter(allow_empty_lines = FALSE, allow_in_strings = TRUE)"},{"path":"https://lintr.r-lib.org/reference/trailing_whitespace_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trailing whitespace linter — trailing_whitespace_linter","text":"allow_empty_lines Suppress lints lines contain whitespace. allow_in_strings Suppress lints trailing whitespace string constants.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/trailing_whitespace_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Trailing whitespace linter — trailing_whitespace_linter","text":"default, style","code":""},{"path":"https://lintr.r-lib.org/reference/undesirable_function_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Undesirable function linter — undesirable_function_linter","title":"Undesirable function linter — undesirable_function_linter","text":"Report use undesirable functions, e.g. base::return(), base::options(), base::sapply() suggest alternative.","code":""},{"path":"https://lintr.r-lib.org/reference/undesirable_function_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Undesirable function linter — undesirable_function_linter","text":"","code":"undesirable_function_linter(   fun = default_undesirable_functions,   symbol_is_undesirable = TRUE )"},{"path":"https://lintr.r-lib.org/reference/undesirable_function_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Undesirable function linter — undesirable_function_linter","text":"fun Named character vector, names names undesirable functions, values text alternative function use (NA). symbol_is_undesirable Whether consider use undesirable function name symbol undesirable .","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/undesirable_function_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Undesirable function linter — undesirable_function_linter","text":"best_practices, configurable, efficiency, robustness, style","code":""},{"path":"https://lintr.r-lib.org/reference/undesirable_operator_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Undesirable operator linter — undesirable_operator_linter","title":"Undesirable operator linter — undesirable_operator_linter","text":"Report use undesirable operators, e.g. ::: <<- suggest alternative.","code":""},{"path":"https://lintr.r-lib.org/reference/undesirable_operator_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Undesirable operator linter — undesirable_operator_linter","text":"","code":"undesirable_operator_linter(op = default_undesirable_operators)"},{"path":"https://lintr.r-lib.org/reference/undesirable_operator_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Undesirable operator linter — undesirable_operator_linter","text":"op Named character vector, names names undesirable operators, values text alternative operator use (NA).","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/undesirable_operator_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Undesirable operator linter — undesirable_operator_linter","text":"best_practices, configurable, efficiency, robustness, style","code":""},{"path":"https://lintr.r-lib.org/reference/unneeded_concatenation_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Unneeded concatenation linter — unneeded_concatenation_linter","title":"Unneeded concatenation linter — unneeded_concatenation_linter","text":"Check c function used without arguments single constant.","code":""},{"path":"https://lintr.r-lib.org/reference/unneeded_concatenation_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unneeded concatenation linter — unneeded_concatenation_linter","text":"","code":"unneeded_concatenation_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/unneeded_concatenation_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Unneeded concatenation linter — unneeded_concatenation_linter","text":"efficiency, readability, style","code":""},{"path":"https://lintr.r-lib.org/reference/unreachable_code_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block unreachable code and comments following return statements — unreachable_code_linter","title":"Block unreachable code and comments following return statements — unreachable_code_linter","text":"Code top-level return() stop() reached; typically vestigial code left refactoring sandboxing code, fine exploration, ultimately checked . Comments meant posterity placed final return().","code":""},{"path":"https://lintr.r-lib.org/reference/unreachable_code_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block unreachable code and comments following return statements — unreachable_code_linter","text":"","code":"unreachable_code_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/unreachable_code_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block unreachable code and comments following return statements — unreachable_code_linter","text":"best_practices, readability","code":""},{"path":"https://lintr.r-lib.org/reference/unused_import_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that imported packages are actually used — unused_import_linter","title":"Check that imported packages are actually used — unused_import_linter","text":"Check imported packages actually used","code":""},{"path":"https://lintr.r-lib.org/reference/unused_import_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that imported packages are actually used — unused_import_linter","text":"","code":"unused_import_linter(   allow_ns_usage = FALSE,   except_packages = c(\"bit64\", \"data.table\", \"tidyverse\") )"},{"path":"https://lintr.r-lib.org/reference/unused_import_linter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that imported packages are actually used — unused_import_linter","text":"allow_ns_usage Suppress lints packages used via namespace. FALSE default pkg::fun() require library(pkg). can use requireNamespace(\"pkg\") ensure package installed without loading . except_packages Character vector packages ignored. usually attached side effects.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/unused_import_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Check that imported packages are actually used — unused_import_linter","text":"best_practices, common_mistakes, configurable","code":""},{"path":"https://lintr.r-lib.org/reference/use_lintr.html","id":null,"dir":"Reference","previous_headings":"","what":"Use lintr in your project — use_lintr","title":"Use lintr in your project — use_lintr","text":"Create minimal lintr config file starting point customization","code":""},{"path":"https://lintr.r-lib.org/reference/use_lintr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use lintr in your project — use_lintr","text":"","code":"use_lintr(path = \".\", type = c(\"tidyverse\", \"full\"))"},{"path":"https://lintr.r-lib.org/reference/use_lintr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use lintr in your project — use_lintr","text":"path Path project root, .lintr file created. .lintr file already exists, error thrown. type kind configuration create? tidyverse creates minimal lintr config, based default linters (linters_with_defaults()). suitable following tidyverse style guide. full creates lintr config using available linters via linters_with_tags().","code":""},{"path":"https://lintr.r-lib.org/reference/use_lintr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use lintr in your project — use_lintr","text":"Path generated configuration, invisibly.","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/use_lintr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use lintr in your project — use_lintr","text":"","code":"if (FALSE) { # use the default set of linters lintr::use_lintr() # or try all linters lintr::use_lintr(type = \"full\")  # then lintr::lint_dir() }"},{"path":"https://lintr.r-lib.org/reference/vector_logic_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Enforce usage of scalar logical operators in conditional statements — vector_logic_linter","title":"Enforce usage of scalar logical operators in conditional statements — vector_logic_linter","text":"Usage & conditional statements error-prone inefficient. condition (condition) expr must always length-1, case && preferred. Ditto | vs. ||.","code":""},{"path":"https://lintr.r-lib.org/reference/vector_logic_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enforce usage of scalar logical operators in conditional statements — vector_logic_linter","text":"","code":"vector_logic_linter()"},{"path":"https://lintr.r-lib.org/reference/vector_logic_linter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enforce usage of scalar logical operators in conditional statements — vector_logic_linter","text":"linter covers inputs () () conditions testthat::expect_true() testthat::expect_false().","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/reference/vector_logic_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Enforce usage of scalar logical operators in conditional statements — vector_logic_linter","text":"best_practices, default, efficiency","code":""},{"path":"https://lintr.r-lib.org/reference/xml_nodes_to_lints.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","title":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","text":"Convenience function converting nodes matched XPath-based linter logic Lint() object return.","code":""},{"path":"https://lintr.r-lib.org/reference/xml_nodes_to_lints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","text":"","code":"xml_nodes_to_lints(   xml,   source_expression,   lint_message,   type = c(\"style\", \"warning\", \"error\"),   column_number_xpath = range_start_xpath,   range_start_xpath = \"number(./@col1)\",   range_end_xpath = \"number(./@col2)\" )"},{"path":"https://lintr.r-lib.org/reference/xml_nodes_to_lints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","text":"xml xml_node object (generate one Lint) xml_nodeset object (generate several Lints), e.g. returned xml2::xml_find_all() xml2::xml_find_first() list xml_node objects. source_expression source expression object, e.g. returned typically lint(), generally get_source_expressions(). lint_message message included message Lint object. lint_message function, function first applied xml (function taking xml_node input must produce length-1 character output). lint_message character vector length xml, -th lint given -th message. type type lint. column_number_xpath XPath expression return column number location lint. Defaults start range matched range_start_xpath. See details information. range_start_xpath XPath expression return range start location lint. Defaults start expression matched xml. See details information. range_end_xpath XPath expression return range end location lint. Defaults end expression matched xml. See details information.","code":""},{"path":"https://lintr.r-lib.org/reference/xml_nodes_to_lints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","text":"xml_nodes, lint. xml_nodesets, lints (list lints).","code":""},{"path":"https://lintr.r-lib.org/reference/xml_nodes_to_lints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert an XML node or nodeset into a Lint — xml_nodes_to_lints","text":"location XPaths, column_number_xpath, range_start_xpath range_end_xpath evaluated using xml2::xml_find_num() usually form \"number(./relative/xpath)\". Note location line number changed lints spanning multiple lines ignore range_end_xpath. column_number_xpath range_start_xpath assumed always refer locations starting line xml node.","code":""},{"path":"https://lintr.r-lib.org/reference/yoda_test_linter.html","id":null,"dir":"Reference","previous_headings":"","what":"Block obvious ","title":"Block obvious ","text":"Yoda tests use (expected, actual) instead common (actual, expected). always possible detect statically; linter focuses simple case testing expression literal value, e.g. (1L, foo(x)) (foo(x), 1L).","code":""},{"path":"https://lintr.r-lib.org/reference/yoda_test_linter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block obvious ","text":"","code":"yoda_test_linter()"},{"path":[]},{"path":"https://lintr.r-lib.org/reference/yoda_test_linter.html","id":"tags","dir":"Reference","previous_headings":"","what":"Tags","title":"Block obvious ","text":"best_practices, package_development, readability","code":""},{"path":[]},{"path":"https://lintr.r-lib.org/news/index.html","id":"potentially-breaking-changes-and-pending-deprecations-development-version","dir":"Changelog","previous_headings":"","what":"Potentially breaking changes and pending deprecations","title":"lintr (development version)","text":"Lints now marked name linter caused instead name implementation function. Deprecated obsolete linter argument Lint(). (#664, #673, #746, @AshesITR) Downstream custom linters follow suit. Consistent access linters function call, even linters without parameters (#245, @fangly, @AshesITR, @MichaelChirico) Removed deprecated functions absolute_paths_linter, camel_case_linter, multiple_dots_linter, snake_case_linter, trailing_semicolons_linter. marked deprecated since v1.0.1, released 2017. Rename semicolon_terminator_linter semicolon_linter better consistency. semicolon_terminator_linter survives marked deprecation. new linter also new signature, taking arguments allow_compound allow_trailing replace old single argument semicolon=, signature consistency linters. closed_curly_linter(), also allowing }] addition }) }, exceptions. open_curly_linter(), longer linting unnecessary trailing whitespace also allowing (, , %>% preceding lines exceptions. (#487, #1028) paren_brace_linter(), also linting /else repeat missing whitespace Require else come line preceding }, present (#884, @michaelchirico) Require functions spanning multiple lines use curly braces (@michaelchirico) Require balanced usage {} /else conditions (@michaelchirico) lint(), ... now 3rd argument, earlier cache= lint_dir() lint_package(), ... now 2nd argument, earlier relative_path= Argument source_file exported functions with_id() ids_with_token() renamed source_expression better reflect argument typically output get_source_expressions(). also renamed argument now-private functional versions many linters, direct effect packages importing linter, mentioned case custom linters imitating lintr style also adopted source_file naming want adapt keep sync. Deprecated with_defaults() favor linters_with_defaults() (#1029, @AshesITR) Removed \"return\" all_undesirable_functions. Follow #1100 upcoming return_linter() lint unnecessary return() statements (#1146, @AshesITR)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"new-features-bug-fixes-improvements-development-version","dir":"Changelog","previous_headings":"","what":"New features, bug fixes, improvements","title":"lintr (development version)","text":"Add exception box::use() declarations infix spaces linter (#1087, @klmr) Writes comments GitHub repo running Jenkins CI (#488, @fdlk) Updated R CMD GitHub Actions workflow check R 3.6 Ubuntu, instead R 3.3, R 4.0 Windows, instead R 3.6 (#803, @ dragosmg) Added secondary, restrictive lint workflow - lint-changed-files - newly written / modified code (#641, @dragosmg) Switched CI Travis GitHub Actions, using full tidyverse recommended R CMD check. Code coverage linting implemented using separate GitHub Actions workflows (#572, @dragosmg) save_cache now recursively create cache directory; avoids errors arise parent directories exist (#60, @dankessler). extract_r_source handles Rmd containing unevaluated code blocks named format specifiers (#472, @russHyde) New style SNAKE_CASE object_name_linter() (#494, @AshesITR) RStudio source markers cleared lints (#520, @AshesITR) seq_linter()’s lint message clearer reason linting. (#522, @michaelchirico) Extension skip programmatic usage loadNamespace() requireNamespace() like loadNamespace(pkg) (#1037, @michaelchirico) New namespace_linter() (#548, #551, @renkun-ken) Fix possible error invalid XML produced xmlparsedata (#559, #560, @renkun-ken) Fix handling zero-length variable name error (#566, #567, @renkun-ken) New missing_argument_linter() (#563, #565, @renkun-ken) New sprintf_linter() (#544, #578, #624, #625, @renkun-ken, @AshesITR) Exclusions specified .lintr file now relative location file support excluding entire directories (#158, #438, @AshesITR) lint_dir() excludes renv packrat directories default (#697, @AshesITR) object_name_linter() now excludes special R hook functions .onLoad (#500, #614, @AshesITR @michaelchirico) Improved generic detection object_name_linter() (#737, @AshesITR) equals_na_linter() now lints x != NA NA == x, skips usages comments (#545, @michaelchirico) Malformed Rmd files now cause lint instead error (#571, #575, @AshesITR) object_name_linter() gains new default style, \"symbols\", won’t lint -symbol object names (particular, means operator names like %+% skipped; #495, #615, #670, @michaelchirico @AshesITR) spaces_inside_linter ignores spaces preceding trailing comments (#636, @michaelchirico) T_and_F_symbol_linter semicolon_terminator_linter now part default linters (#517, #612, #683, #684, @AshesITR) with_defaults() longer duplicates lintr_function class already present (#511, #612, @AshesITR) with_defaults() now warns named argument NULL name default (#1049, @AshesITR) New backport_linter() detecting mismatched R version dependencies (#506, @MichaelChirico) paren_brace_linter no_tab_linter also use reliable matching (e.g., excluding matches found comments; #441 #545, @russHyde) paren_brace_linter now marks lints opening brace instead closing parenthesis, making fixing lints jumping source markers easier (#583, @AshesITR) Extended allow partial matching long supplied prefix unique (#872, @AshesITR) Fixed spaces_left_parentheses_linter sporadically causing warnings (#654, #674, @AshesITR) Fixed line_length_linter causing duplicate lints lines containing multiple expressions (#681, #682, @AshesITR) line_length_linter now places source marker margin affected line improve user experience de-linting – just press Return (#735, @AshesITR) unneeded_concatenation_linter now correctly considers arguments piped via magrittr %>% (#573, #585, @michaelquinn32) Set default complexity_limit cyclocomp_linter 15. complexity limit enforced via default_linters (#693, #695, @AshesITR). lint_package() now lints files demo directory default (#703, @dmurdoch). object_usage_linter() now correctly detects global variables top-level dollar-assignments (#666, #709, @AshesITR) commented_code_linter() uses parse tree find comments, eliminating false positives (#451, @AshesITR) trailing_blank_lines_linter() now also lints files without terminal newline (#675, @AshesITR) object_name_linter() now correctly detects imported functions linting packages (#642, @AshesITR) object_usage_linter() now correctly reports usage warnings spanning multiple lines (#507, @AshesITR) T_and_F_symbol_linter() longer lints occurrences T F used subsetting gives better message used variable names (#657, @AshesITR) with_defaults() handles automatic naming long arguments correctly (#774, @michaelchirico) object_name_linter() longer lints names used subsetting (#582, @AshesITR) lint_package() warns returns NULL package found (instead giving peculiar error message) (#776, @michaelchirico) lint_package() also stricter considers package – folders named DESCRIPTION ignored (#702, @michaelchirico) lint() now new optional argument text supplying string lines directly, e.g. file already memory linting done ad hoc. (#503, @renkun-ken) New pipe_call_linter() enforces steps magrittr pipelines use explicit calls instead symbols, e.g. x %>% mean() instead x %>% mean (@michaelchirico) get_source_expressions() longer fails getParseData() returns truncated (invalid) Unicode character parsed text (#815, #816, @leogama) lintr now supports non-system character Encodings. Auto-detects correct encoding .Rproj DESCRIPTION files project. Override default encoding setting lintr. (#752, #782, @AshesITR) New default linter paren_body_linter() checks space right parenthesis body expression. (#809, #830, @kpagacz) undesirable_function_linter longer lints library require calls attaching package undesired name, e.g. library(foo) (#814, @kpagacz @michaelchirico) New linter duplicate_argument_linter() checks duplicate arguments supplied function calls. (#850, #851, @renkun-ken) Several optional Imported packages become Suggested dependencies: httr, testthat, rstudioapi. allow snappier CI builds usages relying “peripheral” features package. Error message mismatched starts ends exclusion ranges now helpful. (#571, #860, @AshesITR @danielinteractive) Debugging functions (browser(), debug(), debugcall(), debugonce(), trace(), undebug(), untrace()) now part default set undesirable functions help prevent committed mistake. (#876, @michaelchirico) New linter package_hooks_linter() runs series checks also done R CMD check .onLoad(), .onAttach(), .Last.lib() .onDetach() hooks (#882, @MichaelChirico) Improved location information R parse errors (#894, #892, @renkun-ken @AshesITR) linter help page ?linters also links tag help pages, collecting linters similar goal linter can multiple tags New function available_linters() list available linters tags feature extensible package authors providing add-linters {lintr}. New function available_tags() list available tags New function linters_with_tags() help build list linters using tags lintr now uses 3rd edition testthat (@MichaelChirico, @AshesITR, #910, #967) expect_null_linter() Require usage expect_null(x) expect_equal(x, NULL) similar expect_type_linter() Require usage expect_type(x, t) expect_equal(typeof(x), t) similar expect_s3_class_linter() Require usage expect_s3_class(x, k) expect_equal(class(x), k) similar expect_s4_class_linter() Require usage expect_s4_class(x, k) expect_true(methods::(x, k)) Extended #1011 allow forcing R>=4-style named stopifnot() tests separate well expect_not_linter() Require usage expect_false(x) expect_true(!x), vice versa. expect_true_false_linter() Require usage expect_true(x) expect_equal(x, TRUE) similar expect_named_linter() Require usage expect_named(x, n) expect_equal(names(x), n) similar expect_length_linter() Require usage expect_length(x, n) expect_equal(length(x), n) similar Extended #979 improve lint message displayed placeholder tests like expect_equal(1, 1) Extended #1066 exclude tests ends pipelines like foo() %>% expect_equal(2) Extended #1067 exclude $ extractions like expect_equal(x$\"key\", 2) expect_identical_linter() Require usage expect_identical() default, expect_equal() exception expect_comparison_linter() Require usage expect_gt(x, y) expect_true(x > y) similar vector_logic_linter() Require use scalar logical operators (&& ||) inside () conditions similar any_is_na_linter() Require usage anyNA(x) (.na(x)) class_equals_linter() Prevent comparing class(x) ==, !=, %%, inherits() typically preferred outer_negation_linter() Require usage !(x) (!x) !(x) (!x) numeric_leading_zero_linter() Require leading 0 fractional numeric constants, e.g. 0.1 instead .1 literal_coercion_linter() Require using correctly-typed literals instead direct coercion, e.g. 1L instead .numeric(1) paste0() encouraged instead paste(sep = \"\") toString() glue::glue_collapse() encouraged instead paste(x, collapse = \", \") sep= passed paste0() – typically mistake (extension #998) nested_ifelse_linter() Prevent nested calls ifelse() like ifelse(, x, ifelse(B, y, z)), similar condition_message_linter Prevent condition messages constructed like stop(paste(...)) (just stop(...) preferable) redundant_ifelse_linter() Prevent usage like ifelse(& B, TRUE, FALSE) ifelse(C, 0, 1) (latter .numeric(!C)) Require else come line preceding }, present Require balanced usage {} /else conditions Require functions spanning multiple lines use curly braces unreachable_code_linter() Prevent code return() stop() statements never reached (extended #1051 thanks early user testing, thanks @bersbersbers!) regex_subset_linter() Require usage grep(ptn, x, value = TRUE) x[grep(ptn, x)] similar consecutive_stopifnot_linter() Require consecutive calls stopifnot() unified one ifelse_censor_linter() Require usage pmax() / pmin() appropriate, e.g. ifelse(x > y, x, y) pmax(x, y) system_file_linter() Require file paths constructed system.file() instead calling file.path() directly Extended #1036 fix false positive argument name data.frame(c(\"b\" = 1)) inner_combine_linter Require inputs vectorized functions combined first rather later, e.g. .Date(c(x, y)) c(.Date(x), .Date(y)) assignment_linter() now lints right assignment (-> ->>) gains two arguments. allow_cascading_assign (TRUE default) toggles whether lint <<- ->>; allow_right_assign toggles whether lint -> ->> (#915, @michaelchirico) gains argument exclude_operators= disable lints selected infix operators. default, “low-precedence” operators throw lints; see ?infix_spaces_linter enumeration . (#914, @michaelchirico) gains argument allow_multiple_spaces= turn lints operators used multiple spaces, e.g. x  +  2. Turned default allow usage improve alignment line line. (#940, @f-ritter @michaelchirico) now throws lint ~b function(=1) {} (#930, @michaelchirico) object_usage_linter() now detects usages inside glue::glue() constructs (#942, @AshesITR) object_length_linter() correctly detects generics counts implementation class towards length. prevents false positive lints case long generic names, e.g.  very_very_very_long_generic_name.short_class longer produces lint (#871, @AshesITR) object_name_linter() now correctly detects assignment generics (#843, @jonkeane) New unused_import_linter() detect unnecessary library() calls R scripts (#239, @jimhester, @AshesITR) trailing_whitespace_linter() now also lints completely blank lines default. can disabled setting new argument allow_empty_lines = TRUE (#1044, @AshesITR) get_source_expressions() fixes text value STR_CONST nodes involving 1- 2-width octal escapes (e.g. \"\\1\") account R parser bug (https://bugs.r-project.org/show_bug.cgi?id=18323) Several linters tightened internal logic allow raw strings like R\"( \\string )\" (#1034, @michaelchirico) object_usage_linter() correctly detects functions assigned = instead <- (#1081, @michaelchirico) undesirable_function_linter() longer lints undesirable symbols used names (#1050, @AshesITR) trailing_whitespace_linter() ignores trailing whitespace strings default. can disabled using allow_in_strings = FALSE (#1045, @AshesITR) Moved default lintr cache directory ~/.R/lintr_cache R_user_dir(\"lintr\", \"cache\"). Note major version update invalidated old cache anyway, can safely deleted. (#1062, @AshesITR) New is_lint_level() helper readably explaining type expression required custom linter. linters written either require full file’s parse tree (example, single_quotes_linter()). Others need single expressions, cache-friendly (linters written way leverage caching). (#921, @michaelchirico) object_usage_linter() now detects functions exported packages explicitly attached using library() require() calls (#1127, @AshesITR) New helper xml_nodes_to_lints() converting xml_node objects obtained using linter logic expressed XPath Lint objects (#1124, @michaelchirico) Added explanation certain functions operators might undesirable alternatives use (#1133, #1146, #1159, @AshesITR) Improved S3 generic detection non-standard S3 generics (#846, @jonkeane)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-201","dir":"Changelog","previous_headings":"","what":"lintr 2.0.1","title":"lintr 2.0.1","text":"CRAN release: 2020-02-19","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"new-features-2-0-1","dir":"Changelog","previous_headings":"","what":"New features","title":"lintr 2.0.1","text":"lintr now supports GitHub Actions print lints warning messages lints printed action. lint_package() now lint vignettes data-raw default (#447, @AshesITR). lint_dir() now include Rmd Rnw files default (@AshesITR).","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"minor-fixes-and-features-2-0-1","dir":"Changelog","previous_headings":"","what":"Minor fixes and features","title":"lintr 2.0.1","text":"single_quote_linter() longer causes print issue open quote appears column > close quote (#457, @jamieRowen) absolute_path_linter() nonportable_path_linter() now handle file-paths wrapped double-quotes (#433, #437, @russHyde). get_source_expressions() changed handle expr_or_assign_or_help tokens arising parsing code containing equals-assignments R-devel (#403, #456, @russHyde). object_usage_linter changed ensure lint-position indicated relative start file, rather start defining function (#432, @russHyde). commas_linter now allows spaces come comma used denote fall-switch statement (#499, @MrMallIronmaker)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-200","dir":"Changelog","previous_headings":"","what":"lintr 2.0.0","title":"lintr 2.0.0","text":"CRAN release: 2019-10-01 lintr 2.0.0 major release, incorporates development changes since last major release (1.0.0) 2016-04-16.","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"deprecated-functions-2-0-0","dir":"Changelog","previous_headings":"","what":"Deprecated functions","title":"lintr 2.0.0","text":"Deprecated camel_case_linter(), snake_case_linter() multiple_dots_linter() favor object_name_linter() enforce given style: snake_case, dotted.case, lowerCamelCalse, UpperCamelCase, alllowercase ALLUPPERCASE (#59, @fangly). Deprecated absolute_paths_linter() favor new absolute_path_linter(), lax mode fewer false positive lints (#199, fangly).","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"new-linters-2-0-0","dir":"Changelog","previous_headings":"","what":"New linters","title":"lintr 2.0.0","text":"New cyclocomp_linter() identifies overly complex functions (#361, @fabian-s) New equals_na_linter() (#143, #326, @jabranham) New extraction_operator_linter() checks [[ operator used extracting single element object, [ (subsetting) $ (interactive use) (@fangly). New function_left_parentheses_linter() check space function name left parentheses (#204, @jrnold). New implicit_integer_linter() detects round numbers declared integers, .e. 1 instead 1L (@fangly). New nonportable_path_linter() identifies paths constructed without file.path() (@fangly). New paren_brace_linter() checks space right parenthesis opening curly brace (@bfgray3, #242). New pipe_continuation_linter() ensure space %>% newline afterwards (#216). expressions (#181, @fangly). New seq_linter(), finds 1:length(...) (similar) expressions (#155, 1) New todo_comment_linter() lints TODOs (@fangly). New T_and_F_symbol_linter() warns using T F instead TRUE FALSE (@fangly). New undesirable_operator_linter() undesirable_function_linter() lint uses user-specified functions operators (#48, #149, @fangly). New unneeded_concatenation_linter() lints uses c() constant arguments (@fangly).","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"new-functions-for-writing-linters-2-0-0","dir":"Changelog","previous_headings":"","what":"New functions for writing linters","title":"lintr 2.0.0","text":"Export expect_lint() (#178, #210) Export ids_with_token() with_id() (#297 @stufield) linters can use XML parse tree well now, via https://github.com/MangoTheCat/xmlparsedata package (#154, 1)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"new-functions-for-users-2-0-0","dir":"Changelog","previous_headings":"","what":"New functions for users","title":"lintr 2.0.0","text":"New lint_dir() function lint files given directory (@arekbee, #360) New summary.lints() function summarize linter results (#260, #262, @wlandau). New checkstyle_output() function output lints checkstyle XML output (#156, @joshkgold)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"linter-fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"Linter fixes","title":"lintr 2.0.0","text":"closed_curly_linter() now allows closing parenthesis comma closing curly brace (#167, @Enchufa2) commas_linter() now handles missing arguments calls properly (#145) commented_code_linter() now relaxed, longer lints comments within roxygen blocks consider “-” R operator avoid many false positives. function_left_parentheses_linter() now allows spaces function starts left parenthesis (#311) no_tab_linter() now reports proper line cases (#134, @fangly) object_length_linter() argument length now defaults 30 consistency (#325 @DragosMG) object_name_linter() now works passed multiple styles (#341, @infotroph) object_usage_linter() changed better detect lexical scoping global variables (#27, #336, #91, #382) object_usage_linter() now respects utils::globalVariables(), can used avoid false positive warnings due non-standard evaluation (#352) object_usage_linter() now ignores top level calls contain function definitions (#26). object_linter*()s now lint objects declared current file (#76, #108, #136, #191, #194, #201, @fangly). open_curly_linter() closed_curly_linter() now lint double curly syntax (#388) open_curly_linter() now allows comments curly braces (#188) pipe_continuation_linter() now behaves better nested expressions, functions etc. (#366 @russHyde) space_inside_linter() now reports proper line column numbers (#203, @fangly)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"general-improvements-and-fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"General improvements and fixes","title":"lintr 2.0.0","text":"expect_lint() now longer shows Rstudio markers error messages correctly preserved (#180, #211, @fangly) Lint() / .data.frame() error now fixed (#179, @fangly). lint() longer errors inline \\\\Sexpr (#127). lint() longer errors ‘<% %>’ constructs (#185). lint_package() now works cache, intended (#146, @schloerke) lint_package() now excludes R/RcppExports.R default (#282) lint_package() now removes fully excluded files soon possible lintr now looks configuration parent directories well package directory (#238, #345) seq_linter now one default linters (#316). Fix issue lintr’s compatibility R-devel, due new version PCRE library (#411.) read_settings() now better error message config file end newline (#160, #189) expect_lint_free() now automatically skipped run covr (#287) Now lintr tries generate comments running wercker travis CI (#166) Add support overriding GitHub API Token via GITHUB_TOKEN environment variable (#63, @mattyb) Config files now also searched users’ home directory (#266, @randy3k) Fixed crash caused ambiguous cache file paths (#212, @fangly). RStudio addins lint current source project (fixes #264, @JhossePaul) Added proper handling tab characters (fixes #44, @fangly) lintr need igraph package (#152, 1) Fixed cache saved directory requested (#213, @fangly) avoid reading pre-processing ignored files (@mwaldstein) Allow number # start comment. Useful ESS (#299, @prosoitos) R Markdown files contain chunks longer treated code (#370). Fixed plain-code-block bug Rmarkdown (#252, @russHyde) Fixed bug non-R chunks using {lang} engine format parsed R-markdown (#322, @russHyde) Ensured lintr runs / installs / tests R-3.6: pinned github xmlparsedata; ensure vectors length-1 compared using && || (#363 #377 #384 #391, @russHyde).","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-103","dir":"Changelog","previous_headings":"","what":"lintr 1.0.3","title":"lintr 1.0.3","text":"CRAN release: 2018-11-08 Fix tests work changes parser R 3.6","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-102","dir":"Changelog","previous_headings":"","what":"lintr 1.0.2","title":"lintr 1.0.2","text":"CRAN release: 2017-11-08 Fix tests work upcoming testthat release.","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-101","dir":"Changelog","previous_headings":"","what":"lintr 1.0.1","title":"lintr 1.0.1","text":"CRAN release: 2017-08-10 bugfix work knitr 1.16.7 expect_lint_free() now always skipped CRAN. necessary non-binary R source may available running tests CRAN, tests may run package directory.","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-100","dir":"Changelog","previous_headings":"","what":"lintr 1.0.0","title":"lintr 1.0.0","text":"CRAN release: 2016-04-16 bugfix work testthat 1.0.0","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-033","dir":"Changelog","previous_headings":"","what":"lintr 0.3.3","title":"lintr 0.3.3","text":"CRAN release: 2015-09-15 infix_spaces_linter now properly checks = named arguments. (#130, @saurfang). commas_linter now properly recognizes lints preceded blank line points missing space rather comma (#111, #129, @saurfang). Make spaces_left_parentheses_linter robust determining ( type (#128, @saurfang) commented_code_linter (#83, @jackwasey) Now trims long comments (#55, reported @paulstaab) Automatic commenting Github commits pull requests linting Travis-CI expect_lint_free expectation can added testthat unit tests. Robust configuration system exclusion logic Emacs Sublime Text 3 plugins now available respective package repositories. add names.lints, split.lints (#49, @ttriche) Fixed bug caused vim syntatic plugin work properly windows (#46, @abossenbroek) allow lintr customization per project using .lintr config files. use globalenv() instead baseenv() default parent environment methods included. check object usage eval fails. Fixes (#24, reported @fabian-s) trailing_whitespace_linter reporting incorrect line number Use RStudio source marker API display lints (#37, @jjallaire) Permit single quotes quote literal double quotes (#28, @jackwasey) CRAN release: 2015-09-15 Properly handle knitr document formats Allow (( linting (#259, @nathaneastwood) Remove ^ infix spaces conform tidyverse. (#302, @nathaneastwood)","code":""},{"path":"https://lintr.r-lib.org/news/index.html","id":"lintr-020","dir":"Changelog","previous_headings":"","what":"lintr 0.2.0","title":"lintr 0.2.0","text":"CRAN release: 2014-12-01 Initial release","code":""}]
